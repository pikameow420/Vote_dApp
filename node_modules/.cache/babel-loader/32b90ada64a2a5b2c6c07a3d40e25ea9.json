{"ast":null,"code":"/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nvar ObliviousSet = /** @class */function () {\n  function ObliviousSet(ttl) {\n    this.ttl = ttl;\n    this.set = new Set();\n    this.timeMap = new Map();\n  }\n  ObliviousSet.prototype.has = function (value) {\n    return this.set.has(value);\n  };\n  ObliviousSet.prototype.add = function (value) {\n    var _this = this;\n    this.timeMap.set(value, now());\n    this.set.add(value);\n    /**\n     * When a new value is added,\n     * start the cleanup at the next tick\n     * to not block the cpu for more important stuff\n     * that might happen.\n     */\n    setTimeout(function () {\n      removeTooOldValues(_this);\n    }, 0);\n  };\n  ObliviousSet.prototype.clear = function () {\n    this.set.clear();\n    this.timeMap.clear();\n  };\n  return ObliviousSet;\n}();\nexport { ObliviousSet };\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(obliviousSet) {\n  var olderThen = now() - obliviousSet.ttl;\n  var iterator = obliviousSet.set[Symbol.iterator]();\n  /**\n   * Because we can assume the new values are added at the bottom,\n   * we start from the top and stop as soon as we reach a non-too-old value.\n   */\n  while (true) {\n    var value = iterator.next().value;\n    if (!value) {\n      return; // no more elements\n    }\n\n    var time = obliviousSet.timeMap.get(value);\n    if (time < olderThen) {\n      obliviousSet.timeMap.delete(value);\n      obliviousSet.set.delete(value);\n    } else {\n      // We reached a value that is not old enough\n      return;\n    }\n  }\n}\nexport function now() {\n  return new Date().getTime();\n}","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"AACA;;;;AAIG;AACH,IAAA,YAAA,GAAA,aAAA,YAAA;EAGI,SAAA,YAAA,CACoB,GAAW,EAAA;IAAX,IAAA,CAAA,GAAG,GAAH,GAAG;IAHP,IAAA,CAAA,GAAG,GAAG,IAAI,GAAG,EAAE;IACf,IAAA,CAAA,OAAO,GAAG,IAAI,GAAG,EAAE;EAG/B;EAEJ,YAAA,CAAA,SAAA,CAAA,GAAG,GAAH,UAAI,KAAQ,EAAA;IACR,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC;EAC9B,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,GAAG,GAAH,UAAI,KAAQ,EAAA;IAAZ,IAAA,KAAA,GAAA,IAAA;IACI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC;IAC9B,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC;IAEnB;;;;;AAKG;IACH,UAAU,CAAC,YAAA;MACP,kBAAkB,CAAC,KAAI,CAAC;IAC5B,CAAC,EAAE,CAAC,CAAC;EACT,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,KAAK,GAAL,YAAA;IACI,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE;IAChB,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE;EACxB,CAAC;EACL,OAAA,YAAC;AAAD,CAAC,EAAA;;AAGD;;;AAGG;AACH,OAAM,SAAU,kBAAkB,CAC9B,YAA0B,EAAA;EAE1B,IAAM,SAAS,GAAG,GAAG,EAAE,GAAG,YAAY,CAAC,GAAG;EAC1C,IAAM,QAAQ,GAAG,YAAY,CAAC,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE;EAEpD;;;AAGG;EACH,OAAO,IAAI,EAAE;IACT,IAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC,KAAK;IACnC,IAAI,CAAC,KAAK,EAAE;MACR,OAAO,CAAC;IACX;;IACD,IAAM,IAAI,GAAG,YAAY,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC;IAC5C,IAAI,IAAI,GAAG,SAAS,EAAE;MAClB,YAAY,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC;MAClC,YAAY,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC;KACjC,MAAM;MACH;MACA;IACH;EACJ;AACL;AAEA,OAAM,SAAU,GAAG,GAAA;EACf,OAAO,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE;AAC/B","sourceRoot":"","sourcesContent":["/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nvar ObliviousSet = /** @class */ (function () {\n    function ObliviousSet(ttl) {\n        this.ttl = ttl;\n        this.set = new Set();\n        this.timeMap = new Map();\n    }\n    ObliviousSet.prototype.has = function (value) {\n        return this.set.has(value);\n    };\n    ObliviousSet.prototype.add = function (value) {\n        var _this = this;\n        this.timeMap.set(value, now());\n        this.set.add(value);\n        /**\n         * When a new value is added,\n         * start the cleanup at the next tick\n         * to not block the cpu for more important stuff\n         * that might happen.\n         */\n        setTimeout(function () {\n            removeTooOldValues(_this);\n        }, 0);\n    };\n    ObliviousSet.prototype.clear = function () {\n        this.set.clear();\n        this.timeMap.clear();\n    };\n    return ObliviousSet;\n}());\nexport { ObliviousSet };\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(obliviousSet) {\n    var olderThen = now() - obliviousSet.ttl;\n    var iterator = obliviousSet.set[Symbol.iterator]();\n    /**\n     * Because we can assume the new values are added at the bottom,\n     * we start from the top and stop as soon as we reach a non-too-old value.\n     */\n    while (true) {\n        var value = iterator.next().value;\n        if (!value) {\n            return; // no more elements\n        }\n        var time = obliviousSet.timeMap.get(value);\n        if (time < olderThen) {\n            obliviousSet.timeMap.delete(value);\n            obliviousSet.set.delete(value);\n        }\n        else {\n            // We reached a value that is not old enough\n            return;\n        }\n    }\n}\nexport function now() {\n    return new Date().getTime();\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}