{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter } from '@toruslabs/openlogin-jrpc';\nimport { ADAPTER_STATUS, CHAIN_NAMESPACES, WalletInitializationError, storageAvailable, getChainConfig, ADAPTER_NAMESPACES, WalletLoginError, ADAPTER_EVENTS } from '@web3auth/base';\nimport log from 'loglevel';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nconst ADAPTER_CACHE_KEY = \"Web3Auth-cachedAdapter\";\nclass Web3AuthCore extends SafeEventEmitter {\n  constructor(options) {\n    var _options$chainConfig, _options$chainConfig2, _options$chainConfig3, _options$chainConfig4;\n    super();\n    _defineProperty(this, \"coreOptions\", void 0);\n    _defineProperty(this, \"connectedAdapterName\", null);\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n    _defineProperty(this, \"cachedAdapter\", null);\n    _defineProperty(this, \"walletAdapters\", {});\n    if (!((_options$chainConfig = options.chainConfig) !== null && _options$chainConfig !== void 0 && _options$chainConfig.chainNamespace) || !Object.values(CHAIN_NAMESPACES).includes((_options$chainConfig2 = options.chainConfig) === null || _options$chainConfig2 === void 0 ? void 0 : _options$chainConfig2.chainNamespace)) throw WalletInitializationError.invalidParams(\"Please provide a valid chainNamespace in chainConfig\");\n    this.cachedAdapter = storageAvailable(\"sessionStorage\") ? window.sessionStorage.getItem(ADAPTER_CACHE_KEY) : null;\n    this.coreOptions = _objectSpread(_objectSpread({}, options), {}, {\n      chainConfig: _objectSpread(_objectSpread({}, getChainConfig((_options$chainConfig3 = options.chainConfig) === null || _options$chainConfig3 === void 0 ? void 0 : _options$chainConfig3.chainNamespace, (_options$chainConfig4 = options.chainConfig) === null || _options$chainConfig4 === void 0 ? void 0 : _options$chainConfig4.chainId)), options.chainConfig)\n    });\n    this.subscribeToAdapterEvents = this.subscribeToAdapterEvents.bind(this);\n  }\n  get provider() {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) {\n      const adapter = this.walletAdapters[this.connectedAdapterName];\n      return adapter.provider;\n    }\n    return null;\n  }\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n  async init() {\n    const initPromises = Object.keys(this.walletAdapters).map(adapterName => {\n      this.subscribeToAdapterEvents(this.walletAdapters[adapterName]); // if adapter doesn't have any chain config yet thn set it based on provided namespace and chainId.\n      // if no chainNamespace or chainId is being provided, it will connect with mainnet.\n\n      if (!this.walletAdapters[adapterName].chainConfigProxy) {\n        const providedChainConfig = this.coreOptions.chainConfig;\n        if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n        const chainConfig = _objectSpread(_objectSpread({}, getChainConfig(providedChainConfig.chainNamespace, providedChainConfig.chainId)), providedChainConfig);\n        this.walletAdapters[adapterName].setChainConfig(chainConfig);\n      }\n      return this.walletAdapters[adapterName].init({\n        autoConnect: this.cachedAdapter === adapterName\n      }).catch(e => log.error(e));\n    });\n    this.status = ADAPTER_STATUS.READY;\n    await Promise.all(initPromises);\n  }\n  configureAdapter(adapter) {\n    this.checkInitRequirements();\n    const providedChainConfig = this.coreOptions.chainConfig;\n    if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n    const adapterAlreadyExists = this.walletAdapters[adapter.name];\n    if (adapterAlreadyExists) throw WalletInitializationError.duplicateAdapterError(\"Wallet adapter for \".concat(adapter.name, \" already exists\"));\n    if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace) throw WalletInitializationError.incompatibleChainNameSpace(\"This wallet adapter belongs to \".concat(adapter.adapterNamespace, \" which is incompatible with currently used namespace: \").concat(providedChainConfig.chainNamespace));\n    if (adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN && adapter.currentChainNamespace && providedChainConfig.chainNamespace !== adapter.currentChainNamespace) {\n      // chainConfig checks are already validated in constructor so using typecast is safe here.\n      adapter.setChainConfig(providedChainConfig);\n    }\n    this.walletAdapters[adapter.name] = adapter;\n    return this;\n  }\n  clearCache() {\n    if (!storageAvailable(\"sessionStorage\")) return;\n    window.sessionStorage.removeItem(ADAPTER_CACHE_KEY);\n    this.cachedAdapter = null;\n  }\n  /**\n   * Connect to a specific wallet adapter\n   * @param walletName - Key of the walletAdapter to use.\n   */\n\n  async connectTo(walletName, loginParams) {\n    if (!this.walletAdapters[walletName]) throw WalletInitializationError.notFound(\"Please add wallet adapter for \".concat(walletName, \" wallet, before connecting\"));\n    return this.walletAdapters[walletName].connect(loginParams);\n  }\n  async logout() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n    await this.walletAdapters[this.connectedAdapterName].disconnect(options);\n  }\n  async getUserInfo() {\n    log.debug(\"Getting user info\", this.status, this.connectedAdapterName);\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n    return this.walletAdapters[this.connectedAdapterName].getUserInfo();\n  }\n  subscribeToAdapterEvents(walletAdapter) {\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTED, data => {\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.connectedAdapterName = data.adapter;\n      this.cacheWallet(data.adapter);\n      this.emit(ADAPTER_EVENTS.CONNECTED, _objectSpread({}, data));\n      log.debug(\"connected\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, data => {\n      // get back to ready state for rehydrating.\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.DISCONNECTED, data);\n      if (storageAvailable(\"sessionStorage\")) {\n        const cachedAdapter = window.sessionStorage.getItem(ADAPTER_CACHE_KEY);\n        if (this.connectedAdapterName === cachedAdapter) {\n          this.clearCache();\n        }\n      }\n      log.debug(\"disconnected\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTING, data => {\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, data);\n      log.debug(\"connecting\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ERRORED, data => {\n      this.status = ADAPTER_STATUS.ERRORED;\n      this.clearCache();\n      this.emit(ADAPTER_EVENTS.ERRORED, data);\n      log.debug(\"errored\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data => {\n      log.debug(\"adapter data updated\", data);\n      this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);\n    });\n  }\n  checkInitRequirements() {\n    if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady(\"Already pending connection\");\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady(\"Already connected\");\n    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady(\"Adapter is already initialized\");\n  }\n  cacheWallet(walletName) {\n    if (!storageAvailable(\"sessionStorage\")) return;\n    window.sessionStorage.setItem(ADAPTER_CACHE_KEY, walletName);\n    this.cachedAdapter = walletName;\n  }\n}\nexport { Web3AuthCore };","map":{"version":3,"sources":["../src/core.ts"],"names":["ADAPTER_CACHE_KEY","Web3AuthCore","SafeEventEmitter","ADAPTER_STATUS","NOT_READY","constructor","options","chainConfig","chainNamespace","Object","values","CHAIN_NAMESPACES","includes","WalletInitializationError","invalidParams","cachedAdapter","storageAvailable","window","sessionStorage","getItem","coreOptions","getChainConfig","chainId","subscribeToAdapterEvents","bind","provider","status","CONNECTED","connectedAdapterName","adapter","walletAdapters","_","Error","init","initPromises","keys","map","adapterName","chainConfigProxy","providedChainConfig","setChainConfig","autoConnect","catch","e","log","error","READY","Promise","all","configureAdapter","checkInitRequirements","adapterAlreadyExists","name","duplicateAdapterError","adapterNamespace","ADAPTER_NAMESPACES","MULTICHAIN","incompatibleChainNameSpace","currentChainNamespace","clearCache","removeItem","connectTo","walletName","loginParams","notFound","connect","logout","cleanup","WalletLoginError","notConnectedError","disconnect","getUserInfo","debug","walletAdapter","on","ADAPTER_EVENTS","data","cacheWallet","emit","DISCONNECTED","CONNECTING","ERRORED","ADAPTER_DATA_UPDATED","notReady","setItem"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter } from '@toruslabs/openlogin-jrpc';\nimport { ADAPTER_STATUS, CHAIN_NAMESPACES, WalletInitializationError, storageAvailable, getChainConfig, ADAPTER_NAMESPACES, WalletLoginError, ADAPTER_EVENTS } from '@web3auth/base';\nimport log from 'loglevel';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst ADAPTER_CACHE_KEY = \"Web3Auth-cachedAdapter\";\nclass Web3AuthCore extends SafeEventEmitter {\n  constructor(options) {\n    var _options$chainConfig, _options$chainConfig2, _options$chainConfig3, _options$chainConfig4;\n\n    super();\n\n    _defineProperty(this, \"coreOptions\", void 0);\n\n    _defineProperty(this, \"connectedAdapterName\", null);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"cachedAdapter\", null);\n\n    _defineProperty(this, \"walletAdapters\", {});\n\n    if (!((_options$chainConfig = options.chainConfig) !== null && _options$chainConfig !== void 0 && _options$chainConfig.chainNamespace) || !Object.values(CHAIN_NAMESPACES).includes((_options$chainConfig2 = options.chainConfig) === null || _options$chainConfig2 === void 0 ? void 0 : _options$chainConfig2.chainNamespace)) throw WalletInitializationError.invalidParams(\"Please provide a valid chainNamespace in chainConfig\");\n    this.cachedAdapter = storageAvailable(\"sessionStorage\") ? window.sessionStorage.getItem(ADAPTER_CACHE_KEY) : null;\n    this.coreOptions = _objectSpread(_objectSpread({}, options), {}, {\n      chainConfig: _objectSpread(_objectSpread({}, getChainConfig((_options$chainConfig3 = options.chainConfig) === null || _options$chainConfig3 === void 0 ? void 0 : _options$chainConfig3.chainNamespace, (_options$chainConfig4 = options.chainConfig) === null || _options$chainConfig4 === void 0 ? void 0 : _options$chainConfig4.chainId)), options.chainConfig)\n    });\n    this.subscribeToAdapterEvents = this.subscribeToAdapterEvents.bind(this);\n  }\n\n  get provider() {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) {\n      const adapter = this.walletAdapters[this.connectedAdapterName];\n      return adapter.provider;\n    }\n\n    return null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    const initPromises = Object.keys(this.walletAdapters).map(adapterName => {\n      this.subscribeToAdapterEvents(this.walletAdapters[adapterName]); // if adapter doesn't have any chain config yet thn set it based on provided namespace and chainId.\n      // if no chainNamespace or chainId is being provided, it will connect with mainnet.\n\n      if (!this.walletAdapters[adapterName].chainConfigProxy) {\n        const providedChainConfig = this.coreOptions.chainConfig;\n        if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n\n        const chainConfig = _objectSpread(_objectSpread({}, getChainConfig(providedChainConfig.chainNamespace, providedChainConfig.chainId)), providedChainConfig);\n\n        this.walletAdapters[adapterName].setChainConfig(chainConfig);\n      }\n\n      return this.walletAdapters[adapterName].init({\n        autoConnect: this.cachedAdapter === adapterName\n      }).catch(e => log.error(e));\n    });\n    this.status = ADAPTER_STATUS.READY;\n    await Promise.all(initPromises);\n  }\n\n  configureAdapter(adapter) {\n    this.checkInitRequirements();\n    const providedChainConfig = this.coreOptions.chainConfig;\n    if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n    const adapterAlreadyExists = this.walletAdapters[adapter.name];\n    if (adapterAlreadyExists) throw WalletInitializationError.duplicateAdapterError(\"Wallet adapter for \".concat(adapter.name, \" already exists\"));\n    if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace) throw WalletInitializationError.incompatibleChainNameSpace(\"This wallet adapter belongs to \".concat(adapter.adapterNamespace, \" which is incompatible with currently used namespace: \").concat(providedChainConfig.chainNamespace));\n\n    if (adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN && adapter.currentChainNamespace && providedChainConfig.chainNamespace !== adapter.currentChainNamespace) {\n      // chainConfig checks are already validated in constructor so using typecast is safe here.\n      adapter.setChainConfig(providedChainConfig);\n    }\n\n    this.walletAdapters[adapter.name] = adapter;\n    return this;\n  }\n\n  clearCache() {\n    if (!storageAvailable(\"sessionStorage\")) return;\n    window.sessionStorage.removeItem(ADAPTER_CACHE_KEY);\n    this.cachedAdapter = null;\n  }\n  /**\n   * Connect to a specific wallet adapter\n   * @param walletName - Key of the walletAdapter to use.\n   */\n\n\n  async connectTo(walletName, loginParams) {\n    if (!this.walletAdapters[walletName]) throw WalletInitializationError.notFound(\"Please add wallet adapter for \".concat(walletName, \" wallet, before connecting\"));\n    return this.walletAdapters[walletName].connect(loginParams);\n  }\n\n  async logout() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n    await this.walletAdapters[this.connectedAdapterName].disconnect(options);\n  }\n\n  async getUserInfo() {\n    log.debug(\"Getting user info\", this.status, this.connectedAdapterName);\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n    return this.walletAdapters[this.connectedAdapterName].getUserInfo();\n  }\n\n  subscribeToAdapterEvents(walletAdapter) {\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTED, data => {\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.connectedAdapterName = data.adapter;\n      this.cacheWallet(data.adapter);\n      this.emit(ADAPTER_EVENTS.CONNECTED, _objectSpread({}, data));\n      log.debug(\"connected\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, data => {\n      // get back to ready state for rehydrating.\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.DISCONNECTED, data);\n\n      if (storageAvailable(\"sessionStorage\")) {\n        const cachedAdapter = window.sessionStorage.getItem(ADAPTER_CACHE_KEY);\n\n        if (this.connectedAdapterName === cachedAdapter) {\n          this.clearCache();\n        }\n      }\n\n      log.debug(\"disconnected\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTING, data => {\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, data);\n      log.debug(\"connecting\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ERRORED, data => {\n      this.status = ADAPTER_STATUS.ERRORED;\n      this.clearCache();\n      this.emit(ADAPTER_EVENTS.ERRORED, data);\n      log.debug(\"errored\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data => {\n      log.debug(\"adapter data updated\", data);\n      this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);\n    });\n  }\n\n  checkInitRequirements() {\n    if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady(\"Already pending connection\");\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady(\"Already connected\");\n    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady(\"Adapter is already initialized\");\n  }\n\n  cacheWallet(walletName) {\n    if (!storageAvailable(\"sessionStorage\")) return;\n    window.sessionStorage.setItem(ADAPTER_CACHE_KEY, walletName);\n    this.cachedAdapter = walletName;\n  }\n\n}\n\nexport { Web3AuthCore };\n//# sourceMappingURL=core.esm.js.map\n"]},"metadata":{},"sourceType":"module"}