{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { providerFromEngine, createFetchMiddleware } from '@toruslabs/base-controllers';\nimport { mergeMiddleware, createAsyncMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { Transaction, Keypair, Message } from '@solana/web3.js';\nimport bs58 from 'bs58';\nimport { ethErrors } from 'eth-rpc-errors';\nimport nacl from '@toruslabs/tweetnacl-js';\nfunction createGetAccountsMiddleware(_ref) {\n  let {\n    getAccounts\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"getAccounts\") return next();\n    if (!getAccounts) throw new Error(\"WalletMiddleware - opts.getAccounts not provided\"); // This calls from the prefs controller\n\n    const accounts = await getAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createRequestAccountsMiddleware(_ref2) {\n  let {\n    requestAccounts\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"requestAccounts\") return next();\n    if (!requestAccounts) throw new Error(\"WalletMiddleware - opts.requestAccounts not provided\"); // This calls the UI login function\n\n    const accounts = await requestAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(\"WalletMiddleware - \".concat(targetMethod, \" not provided\"));\n    const result = await handler(request);\n    response.result = result;\n    return undefined;\n  });\n}\nfunction createSolanaMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    requestAccounts,\n    signTransaction,\n    signAndSendTransaction,\n    signAllTransactions,\n    signMessage,\n    getPrivateKey\n  } = providerHandlers;\n  return mergeMiddleware([createRequestAccountsMiddleware({\n    requestAccounts\n  }), createGetAccountsMiddleware({\n    getAccounts\n  }), createGenericJRPCMiddleware(\"signTransaction\", signTransaction), createGenericJRPCMiddleware(\"signAndSendTransaction\", signAndSendTransaction), createGenericJRPCMiddleware(\"signAllTransactions\", signAllTransactions), createGenericJRPCMiddleware(\"signMessage\", signMessage), createGenericJRPCMiddleware(\"solanaPrivateKey\", getPrivateKey)]);\n}\nfunction createChainSwitchMiddleware(_ref3) {\n  let {\n    addNewChainConfig,\n    switchSolanaChain\n  } = _ref3;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"addSolanaChain\", addNewChainConfig), createGenericJRPCMiddleware(\"switchSolanaChain\", switchSolanaChain)]);\n}\nfunction createAccountMiddleware(_ref4) {\n  let {\n    updatePrivatekey\n  } = _ref4;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"updateAccount\", updatePrivatekey)]);\n}\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction createInjectedProviderProxyMiddleware(provider) {\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const result = await provider.request(_objectSpread$3({}, req));\n    res.result = result;\n  });\n}\nconst getPhantomHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [];\n    },\n    getAccounts: async () => injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [],\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const transaction = await injectedProvider.signTransaction(txn);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params;\n      const message = await injectedProvider.request({\n        method: \"signMessage\",\n        params: {\n          message: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signAndSendTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const txRes = await injectedProvider.signAndSendTransaction(txn);\n      return {\n        signature: txRes.signature\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params2, _req$params3;\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message) || !((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const txns = req.params.message.map(msg => {\n        const decodedMsg = bs58.decode(msg);\n        return Transaction.from(decodedMsg);\n      });\n      const transaction = await injectedProvider.signAllTransactions(txns);\n      return transaction;\n    }\n  };\n  return providerHandlers;\n};\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass PhantomInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$2(_objectSpread$2({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n  async setupProvider(injectedProvider) {\n    const providerHandlers = getPhantomHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork(injectedProvider);\n  }\n  async lookupNetwork(_) {\n    const {\n      chainConfig\n    } = this.config;\n    this.update({\n      chainId: chainConfig.chainId\n    });\n    return chainConfig.chainId || \"\"; // const genesisHash = await phantomProvider.request<string>({\n    //   method: \"getGenesisHash\",\n    //   params: [],\n    // });\n    // const { chainConfig } = this.config;\n    // if (!genesisHash) throw WalletInitializationError.rpcConnectionError(`Failed to connect with phantom wallet`);\n    // if (chainConfig.chainId !== genesisHash.substring(0, 32))\n    //   throw WalletInitializationError.invalidNetwork(\n    //     `Wallet is connected to wrong network,Please change your network to ${\n    //       SOLANA_NETWORKS[chainConfig.chainId] || chainConfig.displayName\n    //     } from phantom wallet extention.`\n    //   );\n    // return genesisHash.substring(0, 32);\n  }\n}\n\nconst getTorusHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_requestAccounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_accounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signMessage: async req => {\n      var _req$params;\n      const message = await injectedProvider.request({\n        method: \"sign_message\",\n        params: {\n          data: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signTransaction: async req => {\n      var _req$params2;\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"sign_transaction\",\n        params: {\n          message\n        }\n      });\n      const buf = Buffer.from(response, \"hex\");\n      const sendTx = Transaction.from(buf);\n      return sendTx;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"send_transaction\",\n        params: {\n          message\n        }\n      });\n      return {\n        signature: response\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5;\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const messages = [];\n      for (const transaction of req.params.message) {\n        const message = bs58.decode(transaction).toString(\"hex\");\n        messages.push(message);\n      }\n      const response = await injectedProvider.request({\n        method: \"sign_all_transactions\",\n        params: {\n          message: messages\n        }\n      });\n      return response;\n    }\n  };\n  return providerHandlers;\n};\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass TorusInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n  async setupProvider(injectedProvider) {\n    this.handleInjectedProviderUpdate(injectedProvider);\n    await this.setupEngine(injectedProvider);\n  }\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Torus solana provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedChainId = await this.provider.request({\n      method: \"solana_chainId\"\n    });\n    const connectedHexChainId = isHexStrict(connectedChainId.toString()) ? connectedChainId : \"0x\".concat(parseInt(connectedChainId, 10).toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId: this.state.chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return this.state.chainId;\n  }\n  async setupEngine(injectedProvider) {\n    const providerHandlers = getTorusHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n  async handleInjectedProviderUpdate(injectedProvider) {\n    injectedProvider.on(\"accountsChanged\", async accounts => {\n      this.provider.emit(\"accountsChanged\", accounts);\n    });\n    injectedProvider.on(\"chainChanged\", async chainId => {\n      const connectedHexChainId = isHexStrict(chainId) ? chainId : \"0x\".concat(parseInt(chainId, 10).toString(16)); // Check if chainId changed and trigger event\n\n      this.configure({\n        chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n          chainId: connectedHexChainId\n        })\n      });\n      await this.setupProvider(injectedProvider);\n    });\n  }\n}\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n    return next();\n  };\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\nasync function getProviderHandlers(_ref) {\n  let {\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n  const transactionGenerator = serializedTx => {\n    const decodedTx = bs58.decode(serializedTx);\n    const tx = Transaction.populate(Message.from(decodedTx));\n    return tx;\n  };\n  const keyPairGenerator = () => {\n    return Keypair.fromSecretKey(Buffer.from(privKey, \"hex\"));\n  };\n  if (typeof privKey !== \"string\") throw WalletInitializationError.invalidParams(\"privKey must be a string\");\n  const keyPair = keyPairGenerator();\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return [keyPair.publicKey.toBase58()];\n    },\n    getAccounts: async () => [keyPair.publicKey.toBase58()],\n    getPrivateKey: async () => privKey,\n    signTransaction: async req => {\n      var _req$params, _req$params2;\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const transaction = transactionGenerator((_req$params2 = req.params) === null || _req$params2 === void 0 ? void 0 : _req$params2.message);\n      transaction.partialSign(keyPair);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params3;\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const signedMsg = nacl.sign.detached(req.params.message, keyPair.secretKey);\n      return signedMsg;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params4, _req$params5;\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const _providerEngineProxy = getProviderEngineProxy();\n      if (!_providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const transaction = transactionGenerator((_req$params5 = req.params) === null || _req$params5 === void 0 ? void 0 : _req$params5.message);\n      transaction.sign(keyPair);\n      const sig = await _providerEngineProxy.request({\n        method: \"sendTransaction\",\n        params: [bs58.encode(transaction.serialize())]\n      });\n      return {\n        signature: sig\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params6, _req$params7;\n      if (!((_req$params6 = req.params) !== null && _req$params6 !== void 0 && _req$params6.message) || !((_req$params7 = req.params) !== null && _req$params7 !== void 0 && _req$params7.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const signedTransactions = [];\n      for (const tx of ((_req$params8 = req.params) === null || _req$params8 === void 0 ? void 0 : _req$params8.message) || []) {\n        var _req$params8;\n        const transaction = transactionGenerator(tx);\n        transaction.partialSign(keyPair);\n        signedTransactions.push(transaction);\n      }\n      return signedTransactions;\n    }\n  };\n  return providerHandlers;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass SolanaPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n  async setupProvider(privKey) {\n    const providerHandlers = await getProviderHandlers({\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(this.getChainSwitchMiddleware());\n    engine.push(this.getAccountMiddleware());\n    engine.push(solanaMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"requestAccounts\"\n        })\n      });\n    }\n  }\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n    await this.setupProvider(privKey);\n  }\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const health = await this._providerEngineProxy.request({\n      method: \"getHealth\",\n      params: []\n    });\n    const {\n      chainConfig\n    } = this.config;\n    if (health !== \"ok\") throw WalletInitializationError.rpcConnectionError(\"Failed to lookup network for following rpc target: \".concat(chainConfig.rpcTarget));\n    this.update({\n      chainId: chainConfig.chainId\n    });\n    if (this.state.chainId !== chainConfig.chainId) {\n      this.provider.emit(\"chainChanged\", this.state.chainId);\n      this.provider.emit(\"connect\", {\n        chainId: this.state.chainId\n      });\n    }\n    return this.state.chainId;\n  }\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addNewChainConfig: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = req.params;\n        if (!chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n        if (!rpcUrls || rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n        if (!nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.SOLANA,\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"SOL\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Solana\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchSolanaChain: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n        await this.switchChain(req.params);\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.privateKey) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n        const {\n          privateKey\n        } = req.params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n}\n_defineProperty(SolanaPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new SolanaPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\nclass SolanaWallet {\n  constructor(provider) {\n    _defineProperty(this, \"provider\", void 0);\n    this.provider = provider;\n  }\n  async requestAccounts() {\n    const accounts = await this.provider.request({\n      method: \"requestAccounts\",\n      params: {}\n    });\n    return accounts;\n  }\n  async signAndSendTransaction(transaction) {\n    const {\n      signature\n    } = await this.provider.request({\n      method: \"signAndSendTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return {\n      signature\n    };\n  }\n  async signTransaction(transaction) {\n    const signedTransaction = await this.provider.request({\n      method: \"signTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return signedTransaction;\n  }\n  async signAllTransactions(transactions) {\n    const messages = transactions.map(transaction => {\n      return bs58.encode(transaction.serialize({\n        requireAllSignatures: false\n      }));\n    });\n    const signedTransaction = await this.provider.request({\n      method: \"signAllTransactions\",\n      params: {\n        message: messages\n      }\n    });\n    return signedTransaction;\n  }\n  async signMessage(data) {\n    const response = await this.provider.request({\n      method: \"signMessage\",\n      params: {\n        message: data\n      }\n    });\n    return response;\n  }\n  async request(args) {\n    const result = await this.provider.request(args);\n    return result;\n  }\n}\nexport { PhantomInjectedProvider, SolanaPrivateKeyProvider, SolanaWallet, TorusInjectedProvider };","map":{"version":3,"sources":["../src/rpc/solanaRpcMiddlewares.ts","../src/providers/injectedProviders/injectedProviderProxy.ts","../src/providers/injectedProviders/phantom/providerHandlers.ts","../src/providers/injectedProviders/phantom/phantomInjectedProvider.ts","../src/providers/injectedProviders/torus/providerHandlers.ts","../src/providers/injectedProviders/torus/torusInjectedProvider.ts","../src/rpc/JrpcClient.ts","../src/providers/privateKeyProvider/solanaPrivateKeyUtils.ts","../src/providers/privateKeyProvider/solanaPrivateKeyProvider.ts","../src/solanaWallet.ts"],"names":["createGetAccountsMiddleware","getAccounts","createAsyncMiddleware","request","response","next","method","Error","accounts","result","undefined","createRequestAccountsMiddleware","requestAccounts","createGenericJRPCMiddleware","targetMethod","handler","createSolanaMiddleware","providerHandlers","signTransaction","signAndSendTransaction","signAllTransactions","signMessage","getPrivateKey","mergeMiddleware","createChainSwitchMiddleware","addNewChainConfig","switchSolanaChain","createAccountMiddleware","updatePrivatekey","createInjectedProviderProxyMiddleware","provider","req","res","_next","getPhantomHandlers","injectedProvider","publicKey","bs58","encode","toBytes","ethErrors","rpc","methodNotSupported","message","decode","params","txn","Transaction","from","transaction","txRes","signature","length","invalidParams","txns","map","msg","decodedMsg","PhantomInjectedProvider","BaseProvider","constructor","config","state","chainConfig","chainNamespace","CHAIN_NAMESPACES","SOLANA","switchChain","_","Promise","resolve","setupProvider","solanaMiddleware","injectedProviderProxy","engine","JRPCEngine","push","providerFromEngine","updateProviderEngineProxy","lookupNetwork","update","chainId","getTorusHandlers","data","toString","buf","Buffer","sendTx","messages","TorusInjectedProvider","handleInjectedProviderUpdate","setupEngine","custom","code","connectedChainId","connectedHexChainId","isHexStrict","parseInt","WalletInitializationError","rpcConnectionError","emit","on","configure","createChainIdMiddleware","end","createProviderConfigMiddleware","providerConfig","createJsonRpcClient","rpcTarget","fetchMiddleware","createFetchMiddleware","networkMiddleware","getProviderHandlers","privKey","getProviderEngineProxy","transactionGenerator","serializedTx","decodedTx","tx","populate","Message","keyPairGenerator","Keypair","fromSecretKey","keyPair","toBase58","partialSign","signedMsg","nacl","sign","detached","secretKey","_providerEngineProxy","sig","serialize","signedTransactions","SolanaPrivateKeyProvider","providerFactory","enable","privateKey","bind","getChainSwitchMiddleware","getAccountMiddleware","updateAccount","existingKey","getChainConfig","health","chainSwitchHandlers","chainName","rpcUrls","blockExplorerUrls","nativeCurrency","addChain","ticker","symbol","tickerName","name","displayName","blockExplorer","chainSwitchMiddleware","accountHandlers","SolanaWallet","requireAllSignatures","signedTransaction","transactions","args"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { providerFromEngine, createFetchMiddleware } from '@toruslabs/base-controllers';\nimport { mergeMiddleware, createAsyncMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { Transaction, Keypair, Message } from '@solana/web3.js';\nimport bs58 from 'bs58';\nimport { ethErrors } from 'eth-rpc-errors';\nimport nacl from '@toruslabs/tweetnacl-js';\n\nfunction createGetAccountsMiddleware(_ref) {\n  let {\n    getAccounts\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"getAccounts\") return next();\n    if (!getAccounts) throw new Error(\"WalletMiddleware - opts.getAccounts not provided\"); // This calls from the prefs controller\n\n    const accounts = await getAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createRequestAccountsMiddleware(_ref2) {\n  let {\n    requestAccounts\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"requestAccounts\") return next();\n    if (!requestAccounts) throw new Error(\"WalletMiddleware - opts.requestAccounts not provided\"); // This calls the UI login function\n\n    const accounts = await requestAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(\"WalletMiddleware - \".concat(targetMethod, \" not provided\"));\n    const result = await handler(request);\n    response.result = result;\n    return undefined;\n  });\n}\nfunction createSolanaMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    requestAccounts,\n    signTransaction,\n    signAndSendTransaction,\n    signAllTransactions,\n    signMessage,\n    getPrivateKey\n  } = providerHandlers;\n  return mergeMiddleware([createRequestAccountsMiddleware({\n    requestAccounts\n  }), createGetAccountsMiddleware({\n    getAccounts\n  }), createGenericJRPCMiddleware(\"signTransaction\", signTransaction), createGenericJRPCMiddleware(\"signAndSendTransaction\", signAndSendTransaction), createGenericJRPCMiddleware(\"signAllTransactions\", signAllTransactions), createGenericJRPCMiddleware(\"signMessage\", signMessage), createGenericJRPCMiddleware(\"solanaPrivateKey\", getPrivateKey)]);\n}\nfunction createChainSwitchMiddleware(_ref3) {\n  let {\n    addNewChainConfig,\n    switchSolanaChain\n  } = _ref3;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"addSolanaChain\", addNewChainConfig), createGenericJRPCMiddleware(\"switchSolanaChain\", switchSolanaChain)]);\n}\nfunction createAccountMiddleware(_ref4) {\n  let {\n    updatePrivatekey\n  } = _ref4;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"updateAccount\", updatePrivatekey)]);\n}\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction createInjectedProviderProxyMiddleware(provider) {\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const result = await provider.request(_objectSpread$3({}, req));\n    res.result = result;\n  });\n}\n\nconst getPhantomHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [];\n    },\n    getAccounts: async () => injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [],\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const transaction = await injectedProvider.signTransaction(txn);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      const message = await injectedProvider.request({\n        method: \"signMessage\",\n        params: {\n          message: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signAndSendTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const txRes = await injectedProvider.signAndSendTransaction(txn);\n      return {\n        signature: txRes.signature\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params2, _req$params3;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message) || !((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txns = req.params.message.map(msg => {\n        const decodedMsg = bs58.decode(msg);\n        return Transaction.from(decodedMsg);\n      });\n      const transaction = await injectedProvider.signAllTransactions(txns);\n      return transaction;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass PhantomInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$2(_objectSpread$2({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    const providerHandlers = getPhantomHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork(injectedProvider);\n  }\n\n  async lookupNetwork(_) {\n    const {\n      chainConfig\n    } = this.config;\n    this.update({\n      chainId: chainConfig.chainId\n    });\n    return chainConfig.chainId || \"\"; // const genesisHash = await phantomProvider.request<string>({\n    //   method: \"getGenesisHash\",\n    //   params: [],\n    // });\n    // const { chainConfig } = this.config;\n    // if (!genesisHash) throw WalletInitializationError.rpcConnectionError(`Failed to connect with phantom wallet`);\n    // if (chainConfig.chainId !== genesisHash.substring(0, 32))\n    //   throw WalletInitializationError.invalidNetwork(\n    //     `Wallet is connected to wrong network,Please change your network to ${\n    //       SOLANA_NETWORKS[chainConfig.chainId] || chainConfig.displayName\n    //     } from phantom wallet extention.`\n    //   );\n    // return genesisHash.substring(0, 32);\n  }\n\n}\n\nconst getTorusHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_requestAccounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_accounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      const message = await injectedProvider.request({\n        method: \"sign_message\",\n        params: {\n          data: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signTransaction: async req => {\n      var _req$params2;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"sign_transaction\",\n        params: {\n          message\n        }\n      });\n      const buf = Buffer.from(response, \"hex\");\n      const sendTx = Transaction.from(buf);\n      return sendTx;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"send_transaction\",\n        params: {\n          message\n        }\n      });\n      return {\n        signature: response\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const messages = [];\n\n      for (const transaction of req.params.message) {\n        const message = bs58.decode(transaction).toString(\"hex\");\n        messages.push(message);\n      }\n\n      const response = await injectedProvider.request({\n        method: \"sign_all_transactions\",\n        params: {\n          message: messages\n        }\n      });\n      return response;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass TorusInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    this.handleInjectedProviderUpdate(injectedProvider);\n    await this.setupEngine(injectedProvider);\n  }\n\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Torus solana provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedChainId = await this.provider.request({\n      method: \"solana_chainId\"\n    });\n    const connectedHexChainId = isHexStrict(connectedChainId.toString()) ? connectedChainId : \"0x\".concat(parseInt(connectedChainId, 10).toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId: this.state.chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return this.state.chainId;\n  }\n\n  async setupEngine(injectedProvider) {\n    const providerHandlers = getTorusHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async handleInjectedProviderUpdate(injectedProvider) {\n    injectedProvider.on(\"accountsChanged\", async accounts => {\n      this.provider.emit(\"accountsChanged\", accounts);\n    });\n    injectedProvider.on(\"chainChanged\", async chainId => {\n      const connectedHexChainId = isHexStrict(chainId) ? chainId : \"0x\".concat(parseInt(chainId, 10).toString(16)); // Check if chainId changed and trigger event\n\n      this.configure({\n        chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n          chainId: connectedHexChainId\n        })\n      });\n      await this.setupProvider(injectedProvider);\n    });\n  }\n\n}\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nasync function getProviderHandlers(_ref) {\n  let {\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n\n  const transactionGenerator = serializedTx => {\n    const decodedTx = bs58.decode(serializedTx);\n    const tx = Transaction.populate(Message.from(decodedTx));\n    return tx;\n  };\n\n  const keyPairGenerator = () => {\n    return Keypair.fromSecretKey(Buffer.from(privKey, \"hex\"));\n  };\n\n  if (typeof privKey !== \"string\") throw WalletInitializationError.invalidParams(\"privKey must be a string\");\n  const keyPair = keyPairGenerator();\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return [keyPair.publicKey.toBase58()];\n    },\n    getAccounts: async () => [keyPair.publicKey.toBase58()],\n    getPrivateKey: async () => privKey,\n    signTransaction: async req => {\n      var _req$params, _req$params2;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transaction = transactionGenerator((_req$params2 = req.params) === null || _req$params2 === void 0 ? void 0 : _req$params2.message);\n      transaction.partialSign(keyPair);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedMsg = nacl.sign.detached(req.params.message, keyPair.secretKey);\n      return signedMsg;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const _providerEngineProxy = getProviderEngineProxy();\n\n      if (!_providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const transaction = transactionGenerator((_req$params5 = req.params) === null || _req$params5 === void 0 ? void 0 : _req$params5.message);\n      transaction.sign(keyPair);\n      const sig = await _providerEngineProxy.request({\n        method: \"sendTransaction\",\n        params: [bs58.encode(transaction.serialize())]\n      });\n      return {\n        signature: sig\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params6, _req$params7;\n\n      if (!((_req$params6 = req.params) !== null && _req$params6 !== void 0 && _req$params6.message) || !((_req$params7 = req.params) !== null && _req$params7 !== void 0 && _req$params7.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedTransactions = [];\n\n      for (const tx of ((_req$params8 = req.params) === null || _req$params8 === void 0 ? void 0 : _req$params8.message) || []) {\n        var _req$params8;\n\n        const transaction = transactionGenerator(tx);\n        transaction.partialSign(keyPair);\n        signedTransactions.push(transaction);\n      }\n\n      return signedTransactions;\n    }\n  };\n  return providerHandlers;\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass SolanaPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const providerHandlers = await getProviderHandlers({\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(this.getChainSwitchMiddleware());\n    engine.push(this.getAccountMiddleware());\n    engine.push(solanaMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"requestAccounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const health = await this._providerEngineProxy.request({\n      method: \"getHealth\",\n      params: []\n    });\n    const {\n      chainConfig\n    } = this.config;\n    if (health !== \"ok\") throw WalletInitializationError.rpcConnectionError(\"Failed to lookup network for following rpc target: \".concat(chainConfig.rpcTarget));\n    this.update({\n      chainId: chainConfig.chainId\n    });\n\n    if (this.state.chainId !== chainConfig.chainId) {\n      this.provider.emit(\"chainChanged\", this.state.chainId);\n      this.provider.emit(\"connect\", {\n        chainId: this.state.chainId\n      });\n    }\n\n    return this.state.chainId;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addNewChainConfig: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = req.params;\n        if (!chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n        if (!rpcUrls || rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n        if (!nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.SOLANA,\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"SOL\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Solana\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchSolanaChain: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n        await this.switchChain(req.params);\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.privateKey) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n        const {\n          privateKey\n        } = req.params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(SolanaPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new SolanaPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nclass SolanaWallet {\n  constructor(provider) {\n    _defineProperty(this, \"provider\", void 0);\n\n    this.provider = provider;\n  }\n\n  async requestAccounts() {\n    const accounts = await this.provider.request({\n      method: \"requestAccounts\",\n      params: {}\n    });\n    return accounts;\n  }\n\n  async signAndSendTransaction(transaction) {\n    const {\n      signature\n    } = await this.provider.request({\n      method: \"signAndSendTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return {\n      signature\n    };\n  }\n\n  async signTransaction(transaction) {\n    const signedTransaction = await this.provider.request({\n      method: \"signTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signAllTransactions(transactions) {\n    const messages = transactions.map(transaction => {\n      return bs58.encode(transaction.serialize({\n        requireAllSignatures: false\n      }));\n    });\n    const signedTransaction = await this.provider.request({\n      method: \"signAllTransactions\",\n      params: {\n        message: messages\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signMessage(data) {\n    const response = await this.provider.request({\n      method: \"signMessage\",\n      params: {\n        message: data\n      }\n    });\n    return response;\n  }\n\n  async request(args) {\n    const result = await this.provider.request(args);\n    return result;\n  }\n\n}\n\nexport { PhantomInjectedProvider, SolanaPrivateKeyProvider, SolanaWallet, TorusInjectedProvider };\n//# sourceMappingURL=solanaProvider.esm.js.map\n"]},"metadata":{},"sourceType":"module"}