{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { createFetchMiddleware, providerFromEngine, signMessage } from '@toruslabs/base-controllers';\nimport { createScaffoldMiddleware, createAsyncMiddleware, mergeMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, WalletLoginError, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { ethErrors } from 'eth-rpc-errors';\nimport log from 'loglevel';\nimport Common, { Hardfork } from '@ethereumjs/common';\nimport { TransactionFactory } from '@ethereumjs/tx';\nimport { personalSign, signTypedData, SignTypedDataVersion, getEncryptionPublicKey, decrypt } from '@metamask/eth-sig-util';\nimport { privateToAddress, stripHexPrefix } from 'ethereumjs-util';\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction resemblesAddress(str) {\n  // hex prefix 2 + 20 bytes\n  return str.length === 2 + 20 * 2;\n}\nfunction createWalletMiddleware(_ref) {\n  let {\n    getAccounts,\n    getPrivateKey,\n    processDecryptMessage,\n    processEncryptionPublicKey,\n    processEthSignMessage,\n    processPersonalMessage,\n    processTransaction,\n    processSignTransaction,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4\n  } = _ref;\n  if (!getAccounts) {\n    throw new Error(\"opts.getAccounts is required\");\n  } //\n  // utility\n  //\n\n  /**\n   * Validates the keyholder address, and returns a normalized (i.e. lowercase)\n   * copy of it.\n   *\n   * an error\n   */\n\n  async function validateAndNormalizeKeyholder(address, req) {\n    if (typeof address === \"string\" && address.length > 0) {\n      // ensure address is included in provided accounts\n      const accounts = await getAccounts(req);\n      const normalizedAccounts = accounts.map(_address => _address.toLowerCase());\n      const normalizedAddress = address.toLowerCase();\n      if (normalizedAccounts.includes(normalizedAddress)) {\n        return normalizedAddress;\n      }\n    }\n    throw ethErrors.rpc.invalidParams({\n      message: \"Invalid parameters: must provide an Ethereum address.\"\n    });\n  } //\n  // account lookups\n  //\n\n  async function lookupAccounts(req, res) {\n    res.result = await getAccounts(req);\n  }\n  async function lookupDefaultAccount(req, res) {\n    const accounts = await getAccounts(req);\n    res.result = accounts[0] || null;\n  } //\n  // transaction signatures\n  //\n\n  async function sendTransaction(req, res) {\n    if (!processTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processTransaction(txParams, req);\n  }\n  async function signTransaction(req, res) {\n    if (!processSignTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processSignTransaction(txParams, req);\n  } //\n  // message signatures\n  //\n\n  async function ethSign(req, res) {\n    if (!processEthSignMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const extraParams = req.params[2] || {};\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n    res.result = await processEthSignMessage(msgParams, req);\n  }\n  async function signTypedData(req, res) {\n    if (!processTypedMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const message = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const version = \"V1\";\n    const extraParams = req.params[2] || {};\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n    res.result = await processTypedMessage(msgParams, req, version);\n  }\n  async function signTypedDataV3(req, res) {\n    if (!processTypedMessageV3) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V3\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV3(msgParams, req, version);\n  }\n  async function signTypedDataV4(req, res) {\n    if (!processTypedMessageV4) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V4\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV4(msgParams, req, version);\n  }\n  async function personalSign(req, res) {\n    if (!processPersonalMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    } // process normally\n\n    const firstParam = req.params[0];\n    const secondParam = req.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n\n    const extraParams = req.params[2] || {}; // We initially incorrectly ordered these parameters.\n    // To gracefully respect users who adopted this API early,\n    // we are currently gracefully recovering from the wrong param order\n    // when it is clearly identifiable.\n    //\n    // That means when the first param is definitely an address,\n    // and the second param is definitely not, but is hex.\n\n    let address, message;\n    if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {\n      let warning = \"The eth_personalSign method requires params ordered \";\n      warning += \"[message, address]. This was previously handled incorrectly, \";\n      warning += \"and has been corrected automatically. \";\n      warning += \"Please switch this param order for smooth behavior in the future.\";\n      res.warning = warning;\n      address = firstParam;\n      message = secondParam;\n    } else {\n      message = firstParam;\n      address = secondParam;\n    }\n    address = await validateAndNormalizeKeyholder(address, req);\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: message\n    }); // eslint-disable-next-line require-atomic-updates\n\n    res.result = await processPersonalMessage(msgParams, req);\n  }\n  async function encryptionPublicKey(req, res) {\n    if (!processEncryptionPublicKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    res.result = await processEncryptionPublicKey(address, req);\n  }\n  async function decryptMessage(req, res) {\n    if (!processDecryptMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const ciphertext = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const extraParams = req.params[2] || {};\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: ciphertext\n    });\n    res.result = processDecryptMessage(msgParams, req);\n  }\n  async function fetchPrivateKey(req, res) {\n    if (!getPrivateKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    res.result = getPrivateKey(req);\n  }\n  return createScaffoldMiddleware({\n    // account lookups\n    eth_accounts: createAsyncMiddleware(lookupAccounts),\n    eth_private_key: createAsyncMiddleware(fetchPrivateKey),\n    eth_coinbase: createAsyncMiddleware(lookupDefaultAccount),\n    // tx signatures\n    eth_sendTransaction: createAsyncMiddleware(sendTransaction),\n    eth_signTransaction: createAsyncMiddleware(signTransaction),\n    // message signatures\n    eth_sign: createAsyncMiddleware(ethSign),\n    eth_signTypedData: createAsyncMiddleware(signTypedData),\n    eth_signTypedData_v3: createAsyncMiddleware(signTypedDataV3),\n    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),\n    personal_sign: createAsyncMiddleware(personalSign),\n    eth_getEncryptionPublicKey: createAsyncMiddleware(encryptionPublicKey),\n    eth_decrypt: createAsyncMiddleware(decryptMessage)\n  });\n}\nfunction createEthMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  } = providerHandlers;\n  const ethMiddleware = mergeMiddleware([createScaffoldMiddleware({\n    eth_syncing: false\n  }), createWalletMiddleware({\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  })]);\n  return ethMiddleware;\n}\nfunction createChainSwitchMiddleware(_ref) {\n  let {\n    addChain,\n    switchChain\n  } = _ref;\n  async function addNewChain(req, res) {\n    var _req$params;\n    const chainParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chain params\");\n    if (!chainParams.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n    if (!chainParams.rpcUrls || chainParams.rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n    if (!chainParams.nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n    res.result = await addChain(chainParams);\n  }\n  async function updateChain(req, res) {\n    var _req$params2;\n    const chainParams = (_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n    res.result = await switchChain(chainParams);\n  }\n  return createScaffoldMiddleware({\n    wallet_addEthereumChain: createAsyncMiddleware(addNewChain),\n    wallet_switchEthereumChain: createAsyncMiddleware(updateChain)\n  });\n}\nfunction createAccountMiddleware(_ref2) {\n  let {\n    updatePrivatekey\n  } = _ref2;\n  async function updateAccount(req, res) {\n    var _req$params3;\n    const accountParams = (_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.length ? req.params[0] : undefined;\n    if (!(accountParams !== null && accountParams !== void 0 && accountParams.privateKey)) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n    res.result = await updatePrivatekey(accountParams);\n  }\n  return createScaffoldMiddleware({\n    wallet_updateAccount: createAsyncMiddleware(updateAccount)\n  });\n} // #endregion account middlewares\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n    return next();\n  };\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\nfunction getProviderHandlers$1(_ref) {\n  let {\n    connector\n  } = _ref;\n  return {\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getAccounts: async _ => {\n      const {\n        accounts\n      } = connector;\n      if (accounts && accounts.length) {\n        return accounts;\n      }\n      throw new Error(\"Failed to get accounts\");\n    },\n    processTransaction: async (txParams, _) => {\n      const result = await connector.sendTransaction(txParams);\n      return result;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const result = await connector.signTransaction(txParams);\n      return result;\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const result = await connector.signMessage([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const result = await connector.signPersonalMessage([msgParams.data, msgParams.from]);\n      return result;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV3: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processTypedMessageV4: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processEncryptionPublicKey: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processDecryptMessage: _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n  };\n}\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass WalletConnectProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      connector\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state: _objectSpread$1(_objectSpread$1({}, state || {}), {}, {\n        chainId: \"loading\",\n        accounts: []\n      })\n    });\n    _defineProperty(this, \"connector\", null);\n    this.connector = connector || null;\n  }\n  async enable() {\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    await this.setupProvider(this.connector);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n  async setupProvider(connector) {\n    this.onConnectorStateUpdate(connector);\n    await this.setupEngine(connector);\n  }\n  async switchChain(_ref2) {\n    let {\n      chainId\n    } = _ref2;\n    const currentChainConfig = this.getChainConfig(chainId);\n    const {\n      ticker,\n      tickerName,\n      rpcTarget\n    } = currentChainConfig;\n    this.update({\n      chainId: \"loading\"\n    });\n    await this.connector.updateChain({\n      chainId: Number.parseInt(chainId, 16),\n      nativeCurrency: {\n        name: tickerName,\n        symbol: ticker\n      },\n      networkId: Number.parseInt(chainId, 10),\n      rpcUrl: rpcTarget\n    });\n    this.configure({\n      chainConfig: currentChainConfig\n    });\n    await this.lookupNetwork(this.connector);\n  }\n  async lookupNetwork(connector) {\n    if (!connector.connected) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedHexChainId = isHexStrict(connector.chainId.toString()) ? connector.chainId : \"0x\".concat(connector.chainId.toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return connectedHexChainId;\n  }\n  async setupEngine(connector) {\n    const providerHandlers = getProviderHandlers$1({\n      connector\n    });\n    this.update({\n      accounts: connector.accounts || []\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork(connector);\n  }\n  async onConnectorStateUpdate(connector) {\n    connector.on(\"session_update\", async (error, payload) => {\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n      if (error) {\n        this.provider.emit(\"error\", error);\n        return;\n      }\n      const {\n        accounts,\n        chainId: connectedChainId,\n        rpcUrl\n      } = payload; // Check if accounts changed and trigger event\n\n      if (accounts !== null && accounts !== void 0 && accounts.length && this.state.accounts[0] !== accounts[0]) {\n        this.update({\n          accounts\n        }); // await this.setupEngine(connector);\n\n        this.provider.emit(\"accountsChanged\", accounts);\n      }\n      const connectedHexChainId = isHexStrict(connectedChainId) ? connectedChainId : \"0x\".concat(connectedChainId.toString(16)); // Check if chainId changed and trigger event\n\n      if (connectedChainId && this.state.chainId !== connectedHexChainId) {\n        // Handle rpcUrl update\n        this.configure({\n          chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n            chainId: connectedHexChainId,\n            rpcTarget: rpcUrl\n          })\n        });\n        await this.setupEngine(connector);\n      }\n    });\n  }\n}\n_defineProperty(WalletConnectProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new WalletConnectProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.connector);\n  return providerFactory;\n});\nasync function getCommonConfiguration(supportsEIP1559, chainConfig) {\n  const {\n    displayName: name,\n    chainId\n  } = chainConfig;\n  const hardfork = supportsEIP1559 ? Hardfork.London : Hardfork.Berlin;\n  const customChainParams = {\n    name,\n    chainId: chainId === \"loading\" ? 0 : parseInt(chainId, 16),\n    networkId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 10),\n    hardfork\n  };\n  return Common.custom(customChainParams);\n}\nfunction getProviderHandlers(_ref) {\n  let {\n    privKey,\n    chainConfig,\n    getProviderEngineProxy\n  } = _ref;\n  return {\n    getAccounts: async _ => [\"0x\".concat(privateToAddress(Buffer.from(privKey, \"hex\")).toString(\"hex\"))],\n    getPrivateKey: async _ => privKey,\n    processTransaction: async (txParams, _) => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const common = await getCommonConfiguration(!!txParams.maxFeePerGas && !!txParams.maxPriorityFeePerGas, chainConfig);\n      const unsignedEthTx = TransactionFactory.fromTxData(txParams, {\n        common\n      });\n      const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n      const txHash = await providerEngineProxy.request({\n        method: \"eth_sendRawTransaction\",\n        params: [\"0x\".concat(signedTx.toString(\"hex\"))]\n      });\n      return txHash;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const common = await getCommonConfiguration(!!txParams.maxFeePerGas && !!txParams.maxPriorityFeePerGas, chainConfig);\n      const unsignedEthTx = TransactionFactory.fromTxData(txParams, {\n        common\n      });\n      const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n      return \"0x\".concat(signedTx.toString(\"hex\"));\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const rawMessageSig = signMessage(privKey, msgParams.data);\n      return rawMessageSig;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = personalSign({\n        privateKey: privKeyBuffer,\n        data: msgParams.data\n      });\n      return sig;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V1\n      });\n      return sig;\n    },\n    processTypedMessageV3: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV3\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V3\n      });\n      return sig;\n    },\n    processTypedMessageV4: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV4\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V4\n      });\n      return sig;\n    },\n    processEncryptionPublicKey: async (address, _) => {\n      log.info(\"processEncryptionPublicKey\", address);\n      return getEncryptionPublicKey(privKey);\n    },\n    processDecryptMessage: (msgParams, _) => {\n      log.info(\"processDecryptMessage\", msgParams);\n      const stripped = stripHexPrefix(msgParams.data);\n      const buff = Buffer.from(stripped, \"hex\");\n      const decrypted = decrypt({\n        encryptedData: JSON.parse(buff.toString(\"utf8\")),\n        privateKey: privKey\n      });\n      return decrypted;\n    }\n  };\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass EthereumPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state\n    });\n  }\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n  async setupProvider(privKey) {\n    const providerHandlers = getProviderHandlers({\n      privKey,\n      chainConfig: this.config.chainConfig,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const chainSwitchMiddleware = this.getChainSwitchMiddleware();\n    const engine = new JRPCEngine(); // Not a partial anymore because of checks in ctor\n\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(chainSwitchMiddleware);\n    engine.push(this.getAccountMiddleware());\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"eth_accounts\"\n        })\n      });\n    }\n  }\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n    await this.setupProvider(privKey);\n  }\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    if (!chainId) throw ethErrors.rpc.invalidParams(\"chainId is required while lookupNetwork\");\n    const network = await this._providerEngineProxy.request({\n      method: \"net_version\",\n      params: []\n    });\n    if (parseInt(chainId, 16) !== parseInt(network, 10)) throw ethErrors.provider.chainDisconnected(\"Invalid network, net_version is: \".concat(network));\n    log.debug(\"this provider\", this.provider, chainId, this.state.chainId);\n    if (this.state.chainId !== chainId) {\n      this.provider.emit(\"chainChanged\", chainId);\n      this.provider.emit(\"connect\", {\n        chainId\n      });\n    }\n    this.update({\n      chainId\n    });\n    return network;\n  }\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addChain: async params => {\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = params;\n        this.addChain({\n          chainNamespace: \"eip155\",\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"ETH\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Ether\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchChain: async params => {\n        const {\n          chainId\n        } = params;\n        await this.switchChain({\n          chainId\n        });\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async params => {\n        const {\n          privateKey\n        } = params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n}\n_defineProperty(EthereumPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new EthereumPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\nexport { EthereumPrivateKeyProvider, WalletConnectProvider };","map":{"version":3,"sources":["../src/rpc/walletMidddleware.ts","../src/rpc/ethRpcMiddlewares.ts","../src/rpc/jrpcClient.ts","../src/providers/injectedProviders/walletConnectUtils.ts","../src/providers/injectedProviders/WalletConnectProvider.ts","../src/providers/privateKeyProviders/ethPrivatekeyUtils.ts","../src/providers/privateKeyProviders/EthereumPrivateKeyProvider.ts"],"names":["resemblesAddress","str","length","createWalletMiddleware","getAccounts","getPrivateKey","processDecryptMessage","processEncryptionPublicKey","processEthSignMessage","processPersonalMessage","processTransaction","processSignTransaction","processTypedMessage","processTypedMessageV3","processTypedMessageV4","Error","validateAndNormalizeKeyholder","address","req","accounts","normalizedAccounts","map","_address","toLowerCase","normalizedAddress","includes","rpc","invalidParams","message","lookupAccounts","res","result","lookupDefaultAccount","sendTransaction","ethErrors","methodNotSupported","txParams","params","from","signTransaction","ethSign","extraParams","msgParams","data","signTypedData","version","signTypedDataV3","signTypedDataV4","personalSign","firstParam","secondParam","warning","encryptionPublicKey","decryptMessage","ciphertext","fetchPrivateKey","createScaffoldMiddleware","eth_accounts","createAsyncMiddleware","eth_private_key","eth_coinbase","eth_sendTransaction","eth_signTransaction","eth_sign","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","personal_sign","eth_getEncryptionPublicKey","eth_decrypt","createEthMiddleware","providerHandlers","ethMiddleware","mergeMiddleware","eth_syncing","createChainSwitchMiddleware","addChain","switchChain","addNewChain","chainParams","undefined","chainId","rpcUrls","nativeCurrency","updateChain","wallet_addEthereumChain","wallet_switchEthereumChain","createAccountMiddleware","updatePrivatekey","updateAccount","accountParams","privateKey","wallet_updateAccount","createChainIdMiddleware","next","end","method","createProviderConfigMiddleware","providerConfig","createJsonRpcClient","rpcTarget","fetchMiddleware","createFetchMiddleware","networkMiddleware","getProviderHandlers","connector","_","signMessage","signPersonalMessage","log","debug","WalletConnectProvider","BaseProvider","constructor","config","state","chainConfig","chainNamespace","CHAIN_NAMESPACES","EIP155","providerFactory","setupProvider","enable","provider","custom","code","_providerEngineProxy","request","onConnectorStateUpdate","setupEngine","currentChainConfig","getChainConfig","ticker","tickerName","update","Number","parseInt","name","symbol","networkId","rpcUrl","configure","lookupNetwork","connected","WalletLoginError","notConnectedError","connectedHexChainId","isHexStrict","toString","WalletInitializationError","rpcConnectionError","emit","engine","JRPCEngine","push","providerFromEngine","updateProviderEngineProxy","on","error","payload","connectedChainId","getCommonConfiguration","supportsEIP1559","displayName","hardfork","Hardfork","London","Berlin","customChainParams","Common","privKey","getProviderEngineProxy","privateToAddress","Buffer","providerEngineProxy","common","maxFeePerGas","maxPriorityFeePerGas","unsignedEthTx","fromTxData","signedTx","sign","serialize","txHash","rawMessageSig","privKeyBuffer","sig","SignTypedDataVersion","V1","V3","V4","info","getEncryptionPublicKey","stripped","stripHexPrefix","buff","decrypted","decrypt","encryptedData","JSON","parse","EthereumPrivateKeyProvider","bind","chainSwitchMiddleware","getChainSwitchMiddleware","getAccountMiddleware","existingKey","network","chainDisconnected","chainSwitchHandlers","chainName","blockExplorerUrls","blockExplorer","accountHandlers"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { createFetchMiddleware, providerFromEngine, signMessage } from '@toruslabs/base-controllers';\nimport { createScaffoldMiddleware, createAsyncMiddleware, mergeMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, WalletLoginError, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { ethErrors } from 'eth-rpc-errors';\nimport log from 'loglevel';\nimport Common, { Hardfork } from '@ethereumjs/common';\nimport { TransactionFactory } from '@ethereumjs/tx';\nimport { personalSign, signTypedData, SignTypedDataVersion, getEncryptionPublicKey, decrypt } from '@metamask/eth-sig-util';\nimport { privateToAddress, stripHexPrefix } from 'ethereumjs-util';\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction resemblesAddress(str) {\n  // hex prefix 2 + 20 bytes\n  return str.length === 2 + 20 * 2;\n}\n\nfunction createWalletMiddleware(_ref) {\n  let {\n    getAccounts,\n    getPrivateKey,\n    processDecryptMessage,\n    processEncryptionPublicKey,\n    processEthSignMessage,\n    processPersonalMessage,\n    processTransaction,\n    processSignTransaction,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4\n  } = _ref;\n\n  if (!getAccounts) {\n    throw new Error(\"opts.getAccounts is required\");\n  } //\n  // utility\n  //\n\n  /**\n   * Validates the keyholder address, and returns a normalized (i.e. lowercase)\n   * copy of it.\n   *\n   * an error\n   */\n\n\n  async function validateAndNormalizeKeyholder(address, req) {\n    if (typeof address === \"string\" && address.length > 0) {\n      // ensure address is included in provided accounts\n      const accounts = await getAccounts(req);\n      const normalizedAccounts = accounts.map(_address => _address.toLowerCase());\n      const normalizedAddress = address.toLowerCase();\n\n      if (normalizedAccounts.includes(normalizedAddress)) {\n        return normalizedAddress;\n      }\n    }\n\n    throw ethErrors.rpc.invalidParams({\n      message: \"Invalid parameters: must provide an Ethereum address.\"\n    });\n  } //\n  // account lookups\n  //\n\n\n  async function lookupAccounts(req, res) {\n    res.result = await getAccounts(req);\n  }\n\n  async function lookupDefaultAccount(req, res) {\n    const accounts = await getAccounts(req);\n    res.result = accounts[0] || null;\n  } //\n  // transaction signatures\n  //\n\n\n  async function sendTransaction(req, res) {\n    if (!processTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processTransaction(txParams, req);\n  }\n\n  async function signTransaction(req, res) {\n    if (!processSignTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processSignTransaction(txParams, req);\n  } //\n  // message signatures\n  //\n\n\n  async function ethSign(req, res) {\n    if (!processEthSignMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processEthSignMessage(msgParams, req);\n  }\n\n  async function signTypedData(req, res) {\n    if (!processTypedMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const message = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const version = \"V1\";\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processTypedMessage(msgParams, req, version);\n  }\n\n  async function signTypedDataV3(req, res) {\n    if (!processTypedMessageV3) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V3\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV3(msgParams, req, version);\n  }\n\n  async function signTypedDataV4(req, res) {\n    if (!processTypedMessageV4) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V4\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV4(msgParams, req, version);\n  }\n\n  async function personalSign(req, res) {\n    if (!processPersonalMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    } // process normally\n\n\n    const firstParam = req.params[0];\n    const secondParam = req.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n\n    const extraParams = req.params[2] || {}; // We initially incorrectly ordered these parameters.\n    // To gracefully respect users who adopted this API early,\n    // we are currently gracefully recovering from the wrong param order\n    // when it is clearly identifiable.\n    //\n    // That means when the first param is definitely an address,\n    // and the second param is definitely not, but is hex.\n\n    let address, message;\n\n    if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {\n      let warning = \"The eth_personalSign method requires params ordered \";\n      warning += \"[message, address]. This was previously handled incorrectly, \";\n      warning += \"and has been corrected automatically. \";\n      warning += \"Please switch this param order for smooth behavior in the future.\";\n      res.warning = warning;\n      address = firstParam;\n      message = secondParam;\n    } else {\n      message = firstParam;\n      address = secondParam;\n    }\n\n    address = await validateAndNormalizeKeyholder(address, req);\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: message\n    }); // eslint-disable-next-line require-atomic-updates\n\n\n    res.result = await processPersonalMessage(msgParams, req);\n  }\n\n  async function encryptionPublicKey(req, res) {\n    if (!processEncryptionPublicKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    res.result = await processEncryptionPublicKey(address, req);\n  }\n\n  async function decryptMessage(req, res) {\n    if (!processDecryptMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const ciphertext = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: ciphertext\n    });\n\n    res.result = processDecryptMessage(msgParams, req);\n  }\n\n  async function fetchPrivateKey(req, res) {\n    if (!getPrivateKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    res.result = getPrivateKey(req);\n  }\n\n  return createScaffoldMiddleware({\n    // account lookups\n    eth_accounts: createAsyncMiddleware(lookupAccounts),\n    eth_private_key: createAsyncMiddleware(fetchPrivateKey),\n    eth_coinbase: createAsyncMiddleware(lookupDefaultAccount),\n    // tx signatures\n    eth_sendTransaction: createAsyncMiddleware(sendTransaction),\n    eth_signTransaction: createAsyncMiddleware(signTransaction),\n    // message signatures\n    eth_sign: createAsyncMiddleware(ethSign),\n    eth_signTypedData: createAsyncMiddleware(signTypedData),\n    eth_signTypedData_v3: createAsyncMiddleware(signTypedDataV3),\n    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),\n    personal_sign: createAsyncMiddleware(personalSign),\n    eth_getEncryptionPublicKey: createAsyncMiddleware(encryptionPublicKey),\n    eth_decrypt: createAsyncMiddleware(decryptMessage)\n  });\n}\n\nfunction createEthMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  } = providerHandlers;\n  const ethMiddleware = mergeMiddleware([createScaffoldMiddleware({\n    eth_syncing: false\n  }), createWalletMiddleware({\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  })]);\n  return ethMiddleware;\n}\nfunction createChainSwitchMiddleware(_ref) {\n  let {\n    addChain,\n    switchChain\n  } = _ref;\n\n  async function addNewChain(req, res) {\n    var _req$params;\n\n    const chainParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chain params\");\n    if (!chainParams.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n    if (!chainParams.rpcUrls || chainParams.rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n    if (!chainParams.nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n    res.result = await addChain(chainParams);\n  }\n\n  async function updateChain(req, res) {\n    var _req$params2;\n\n    const chainParams = (_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n    res.result = await switchChain(chainParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_addEthereumChain: createAsyncMiddleware(addNewChain),\n    wallet_switchEthereumChain: createAsyncMiddleware(updateChain)\n  });\n}\nfunction createAccountMiddleware(_ref2) {\n  let {\n    updatePrivatekey\n  } = _ref2;\n\n  async function updateAccount(req, res) {\n    var _req$params3;\n\n    const accountParams = (_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.length ? req.params[0] : undefined;\n    if (!(accountParams !== null && accountParams !== void 0 && accountParams.privateKey)) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n    res.result = await updatePrivatekey(accountParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_updateAccount: createAsyncMiddleware(updateAccount)\n  });\n} // #endregion account middlewares\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nfunction getProviderHandlers$1(_ref) {\n  let {\n    connector\n  } = _ref;\n  return {\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getAccounts: async _ => {\n      const {\n        accounts\n      } = connector;\n\n      if (accounts && accounts.length) {\n        return accounts;\n      }\n\n      throw new Error(\"Failed to get accounts\");\n    },\n    processTransaction: async (txParams, _) => {\n      const result = await connector.sendTransaction(txParams);\n      return result;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const result = await connector.signTransaction(txParams);\n      return result;\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const result = await connector.signMessage([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const result = await connector.signPersonalMessage([msgParams.data, msgParams.from]);\n      return result;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV3: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processTypedMessageV4: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processEncryptionPublicKey: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processDecryptMessage: _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n  };\n}\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass WalletConnectProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      connector\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state: _objectSpread$1(_objectSpread$1({}, state || {}), {}, {\n        chainId: \"loading\",\n        accounts: []\n      })\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    this.connector = connector || null;\n  }\n\n  async enable() {\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    await this.setupProvider(this.connector);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(connector) {\n    this.onConnectorStateUpdate(connector);\n    await this.setupEngine(connector);\n  }\n\n  async switchChain(_ref2) {\n    let {\n      chainId\n    } = _ref2;\n    const currentChainConfig = this.getChainConfig(chainId);\n    const {\n      ticker,\n      tickerName,\n      rpcTarget\n    } = currentChainConfig;\n    this.update({\n      chainId: \"loading\"\n    });\n    await this.connector.updateChain({\n      chainId: Number.parseInt(chainId, 16),\n      nativeCurrency: {\n        name: tickerName,\n        symbol: ticker\n      },\n      networkId: Number.parseInt(chainId, 10),\n      rpcUrl: rpcTarget\n    });\n    this.configure({\n      chainConfig: currentChainConfig\n    });\n    await this.lookupNetwork(this.connector);\n  }\n\n  async lookupNetwork(connector) {\n    if (!connector.connected) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedHexChainId = isHexStrict(connector.chainId.toString()) ? connector.chainId : \"0x\".concat(connector.chainId.toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return connectedHexChainId;\n  }\n\n  async setupEngine(connector) {\n    const providerHandlers = getProviderHandlers$1({\n      connector\n    });\n    this.update({\n      accounts: connector.accounts || []\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork(connector);\n  }\n\n  async onConnectorStateUpdate(connector) {\n    connector.on(\"session_update\", async (error, payload) => {\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n\n      if (error) {\n        this.provider.emit(\"error\", error);\n        return;\n      }\n\n      const {\n        accounts,\n        chainId: connectedChainId,\n        rpcUrl\n      } = payload; // Check if accounts changed and trigger event\n\n      if (accounts !== null && accounts !== void 0 && accounts.length && this.state.accounts[0] !== accounts[0]) {\n        this.update({\n          accounts\n        }); // await this.setupEngine(connector);\n\n        this.provider.emit(\"accountsChanged\", accounts);\n      }\n\n      const connectedHexChainId = isHexStrict(connectedChainId) ? connectedChainId : \"0x\".concat(connectedChainId.toString(16)); // Check if chainId changed and trigger event\n\n      if (connectedChainId && this.state.chainId !== connectedHexChainId) {\n        // Handle rpcUrl update\n        this.configure({\n          chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n            chainId: connectedHexChainId,\n            rpcTarget: rpcUrl\n          })\n        });\n        await this.setupEngine(connector);\n      }\n    });\n  }\n\n}\n\n_defineProperty(WalletConnectProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new WalletConnectProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.connector);\n  return providerFactory;\n});\n\nasync function getCommonConfiguration(supportsEIP1559, chainConfig) {\n  const {\n    displayName: name,\n    chainId\n  } = chainConfig;\n  const hardfork = supportsEIP1559 ? Hardfork.London : Hardfork.Berlin;\n  const customChainParams = {\n    name,\n    chainId: chainId === \"loading\" ? 0 : parseInt(chainId, 16),\n    networkId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 10),\n    hardfork\n  };\n  return Common.custom(customChainParams);\n}\n\nfunction getProviderHandlers(_ref) {\n  let {\n    privKey,\n    chainConfig,\n    getProviderEngineProxy\n  } = _ref;\n  return {\n    getAccounts: async _ => [\"0x\".concat(privateToAddress(Buffer.from(privKey, \"hex\")).toString(\"hex\"))],\n    getPrivateKey: async _ => privKey,\n    processTransaction: async (txParams, _) => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const common = await getCommonConfiguration(!!txParams.maxFeePerGas && !!txParams.maxPriorityFeePerGas, chainConfig);\n      const unsignedEthTx = TransactionFactory.fromTxData(txParams, {\n        common\n      });\n      const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n      const txHash = await providerEngineProxy.request({\n        method: \"eth_sendRawTransaction\",\n        params: [\"0x\".concat(signedTx.toString(\"hex\"))]\n      });\n      return txHash;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const common = await getCommonConfiguration(!!txParams.maxFeePerGas && !!txParams.maxPriorityFeePerGas, chainConfig);\n      const unsignedEthTx = TransactionFactory.fromTxData(txParams, {\n        common\n      });\n      const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n      return \"0x\".concat(signedTx.toString(\"hex\"));\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const rawMessageSig = signMessage(privKey, msgParams.data);\n      return rawMessageSig;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = personalSign({\n        privateKey: privKeyBuffer,\n        data: msgParams.data\n      });\n      return sig;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V1\n      });\n      return sig;\n    },\n    processTypedMessageV3: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV3\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V3\n      });\n      return sig;\n    },\n    processTypedMessageV4: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV4\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V4\n      });\n      return sig;\n    },\n    processEncryptionPublicKey: async (address, _) => {\n      log.info(\"processEncryptionPublicKey\", address);\n      return getEncryptionPublicKey(privKey);\n    },\n    processDecryptMessage: (msgParams, _) => {\n      log.info(\"processDecryptMessage\", msgParams);\n      const stripped = stripHexPrefix(msgParams.data);\n      const buff = Buffer.from(stripped, \"hex\");\n      const decrypted = decrypt({\n        encryptedData: JSON.parse(buff.toString(\"utf8\")),\n        privateKey: privKey\n      });\n      return decrypted;\n    }\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass EthereumPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const providerHandlers = getProviderHandlers({\n      privKey,\n      chainConfig: this.config.chainConfig,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const chainSwitchMiddleware = this.getChainSwitchMiddleware();\n    const engine = new JRPCEngine(); // Not a partial anymore because of checks in ctor\n\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(chainSwitchMiddleware);\n    engine.push(this.getAccountMiddleware());\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"eth_accounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    if (!chainId) throw ethErrors.rpc.invalidParams(\"chainId is required while lookupNetwork\");\n    const network = await this._providerEngineProxy.request({\n      method: \"net_version\",\n      params: []\n    });\n    if (parseInt(chainId, 16) !== parseInt(network, 10)) throw ethErrors.provider.chainDisconnected(\"Invalid network, net_version is: \".concat(network));\n    log.debug(\"this provider\", this.provider, chainId, this.state.chainId);\n\n    if (this.state.chainId !== chainId) {\n      this.provider.emit(\"chainChanged\", chainId);\n      this.provider.emit(\"connect\", {\n        chainId\n      });\n    }\n\n    this.update({\n      chainId\n    });\n    return network;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addChain: async params => {\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = params;\n        this.addChain({\n          chainNamespace: \"eip155\",\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"ETH\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Ether\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchChain: async params => {\n        const {\n          chainId\n        } = params;\n        await this.switchChain({\n          chainId\n        });\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async params => {\n        const {\n          privateKey\n        } = params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(EthereumPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new EthereumPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nexport { EthereumPrivateKeyProvider, WalletConnectProvider };\n//# sourceMappingURL=ethereumProvider.esm.js.map\n"]},"metadata":{},"sourceType":"module"}