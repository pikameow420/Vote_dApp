{"ast":null,"code":"import OpenLogin, { OPENLOGIN_NETWORK, UX_MODE, getHashQueryParams } from '@toruslabs/openlogin';\nimport { getChainConfig, BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, CHAIN_NAMESPACES, WalletInitializationError, ADAPTER_EVENTS, WalletLoginError } from '@web3auth/base';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport merge from 'lodash.merge';\nimport log from 'loglevel';\nconst getOpenloginDefaultOptions = (chainNamespace, chainId) => {\n  return {\n    adapterSettings: {\n      network: OPENLOGIN_NETWORK.MAINNET,\n      clientId: \"\",\n      uxMode: UX_MODE.POPUP\n    },\n    chainConfig: chainNamespace ? getChainConfig(chainNamespace, chainId) : undefined,\n    loginSettings: {\n      relogin: true\n    }\n  };\n};\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass OpenloginAdapter extends BaseAdapter {\n  constructor(params) {\n    var _params$chainConfig, _params$chainConfig2, _params$chainConfig3;\n    super();\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.OPENLOGIN);\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.MULTICHAIN);\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.IN_APP);\n    _defineProperty(this, \"openloginInstance\", null);\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n    _defineProperty(this, \"openloginOptions\", void 0);\n    _defineProperty(this, \"loginSettings\", {});\n    _defineProperty(this, \"privKeyProvider\", null);\n    log.debug(\"const openlogin adapter\", params);\n    const defaultOptions = getOpenloginDefaultOptions((_params$chainConfig = params.chainConfig) === null || _params$chainConfig === void 0 ? void 0 : _params$chainConfig.chainNamespace, (_params$chainConfig2 = params.chainConfig) === null || _params$chainConfig2 === void 0 ? void 0 : _params$chainConfig2.chainId);\n    this.openloginOptions = _objectSpread(_objectSpread({\n      clientId: \"\",\n      network: OPENLOGIN_NETWORK.MAINNET\n    }, defaultOptions.adapterSettings), params.adapterSettings || {});\n    this.loginSettings = _objectSpread(_objectSpread({}, defaultOptions.loginSettings), params.loginSettings); // if no chainNamespace is passed then chain config should be set before calling init\n\n    if ((_params$chainConfig3 = params.chainConfig) !== null && _params$chainConfig3 !== void 0 && _params$chainConfig3.chainNamespace) {\n      var _params$chainConfig4;\n      this.currentChainNamespace = (_params$chainConfig4 = params.chainConfig) === null || _params$chainConfig4 === void 0 ? void 0 : _params$chainConfig4.chainNamespace;\n      const defaultChainIdConfig = defaultOptions.chainConfig ? defaultOptions.chainConfig : {};\n      this.chainConfig = _objectSpread(_objectSpread({}, defaultChainIdConfig), params === null || params === void 0 ? void 0 : params.chainConfig);\n      log.debug(\"const openlogin chainConfig\", this.chainConfig);\n      if (!this.chainConfig.rpcTarget) {\n        throw WalletInitializationError.invalidParams(\"rpcTarget is required in chainConfig\");\n      }\n    }\n  }\n  get chainConfigProxy() {\n    return this.chainConfig ? _objectSpread({}, this.chainConfig) : null;\n  }\n  get provider() {\n    var _this$privKeyProvider;\n    return ((_this$privKeyProvider = this.privKeyProvider) === null || _this$privKeyProvider === void 0 ? void 0 : _this$privKeyProvider.provider) || null;\n  }\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n  async init(options) {\n    var _this$openloginOption;\n    super.checkInitializationRequirements();\n    if (!((_this$openloginOption = this.openloginOptions) !== null && _this$openloginOption !== void 0 && _this$openloginOption.clientId)) throw WalletInitializationError.invalidParams(\"clientId is required before openlogin's initialization\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    this.openloginInstance = new OpenLogin(this.openloginOptions);\n    const redirectResult = getHashQueryParams();\n    let isRedirectResult = true;\n    if (Object.keys(redirectResult).length > 0 && redirectResult.result) {\n      isRedirectResult = true;\n    }\n    await this.openloginInstance.init();\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.OPENLOGIN);\n    try {\n      // connect only if it is redirect result or if connect (adapter is cached/already connected in same session) is true\n      if (this.openloginInstance.privKey && (options.autoConnect || isRedirectResult)) {\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached openlogin provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n  async connect(params) {\n    super.checkConnectionRequirements();\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, _objectSpread(_objectSpread({}, params), {}, {\n      adapter: WALLET_ADAPTERS.OPENLOGIN\n    }));\n    try {\n      await this.connectWithProvider(params);\n      return this.provider;\n    } catch (error) {\n      log.error(\"Failed to connect with openlogin provider\", error); // ready again to be connected\n\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      if (error !== null && error !== void 0 && error.message.includes(\"user closed popup\")) {\n        throw WalletLoginError.popupClosed();\n      }\n      throw WalletLoginError.connectionError(\"Failed to login with openlogin\");\n    }\n  }\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    await this.openloginInstance.logout();\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.openloginInstance = null;\n      this.privKeyProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n  async getUserInfo() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    const userInfo = await this.openloginInstance.getUserInfo();\n    return userInfo;\n  } // should be called only before initialization.\n\n  setAdapterSettings(adapterSettings) {\n    if (this.status === ADAPTER_STATUS.READY) return;\n    const defaultOptions = getOpenloginDefaultOptions();\n    this.openloginOptions = _objectSpread(_objectSpread(_objectSpread({}, defaultOptions.adapterSettings), this.openloginOptions || {}), adapterSettings);\n  } // should be called only before initialization.\n\n  setChainConfig(customChainConfig) {\n    super.setChainConfig(customChainConfig);\n    this.currentChainNamespace = customChainConfig.chainNamespace;\n  }\n  async connectWithProvider(params) {\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n      const {\n        SolanaPrivateKeyProvider\n      } = await import('@web3auth/solana-provider');\n      this.privKeyProvider = new SolanaPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.EIP155) {\n      const {\n        EthereumPrivateKeyProvider\n      } = await import('@web3auth/ethereum-provider');\n      this.privKeyProvider = new EthereumPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else {\n      throw new Error(\"Invalid chainNamespace: \".concat(this.currentChainNamespace, \" found while connecting to wallet\"));\n    } // if not logged in then login\n\n    if (!this.openloginInstance.privKey && params) {\n      await this.openloginInstance.login(merge(this.loginSettings, {\n        loginProvider: params.loginProvider\n      }, {\n        extraLoginOptions: {\n          login_hint: params === null || params === void 0 ? void 0 : params.login_hint\n        }\n      }));\n    }\n    let finalPrivKey = this.openloginInstance.privKey;\n    if (finalPrivKey) {\n      if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n        const {\n          getED25519Key\n        } = await import('@toruslabs/openlogin-ed25519');\n        finalPrivKey = getED25519Key(finalPrivKey).sk.toString(\"hex\");\n      }\n      await this.privKeyProvider.setupProvider(finalPrivKey);\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.emit(ADAPTER_EVENTS.CONNECTED, {\n        adapter: WALLET_ADAPTERS.OPENLOGIN,\n        reconnected: !params\n      });\n    }\n  }\n}\nexport { OpenloginAdapter, getOpenloginDefaultOptions };","map":{"version":3,"sources":["../src/config.ts","../src/openloginAdapter.ts"],"names":["getOpenloginDefaultOptions","chainNamespace","chainId","adapterSettings","network","OPENLOGIN_NETWORK","MAINNET","clientId","uxMode","UX_MODE","POPUP","chainConfig","getChainConfig","undefined","loginSettings","relogin","OpenloginAdapter","BaseAdapter","WALLET_ADAPTERS","OPENLOGIN","ADAPTER_NAMESPACES","MULTICHAIN","ADAPTER_CATEGORY","IN_APP","ADAPTER_STATUS","NOT_READY","CHAIN_NAMESPACES","EIP155","constructor","params","log","debug","defaultOptions","openloginOptions","currentChainNamespace","defaultChainIdConfig","rpcTarget","WalletInitializationError","invalidParams","chainConfigProxy","provider","privKeyProvider","_","Error","init","options","checkInitializationRequirements","openloginInstance","OpenLogin","redirectResult","getHashQueryParams","isRedirectResult","Object","keys","length","result","status","READY","emit","ADAPTER_EVENTS","privKey","autoConnect","connect","error","checkConnectionRequirements","CONNECTING","adapter","connectWithProvider","ERRORED","message","includes","WalletLoginError","popupClosed","connectionError","disconnect","cleanup","CONNECTED","notConnectedError","notReady","logout","DISCONNECTED","getUserInfo","userInfo","setAdapterSettings","setChainConfig","customChainConfig","SOLANA","SolanaPrivateKeyProvider","config","EthereumPrivateKeyProvider","login","merge","loginProvider","extraLoginOptions","login_hint","finalPrivKey","getED25519Key","sk","toString","setupProvider","reconnected"],"mappings":"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","sourcesContent":["import OpenLogin, { OPENLOGIN_NETWORK, UX_MODE, getHashQueryParams } from '@toruslabs/openlogin';\nimport { getChainConfig, BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, CHAIN_NAMESPACES, WalletInitializationError, ADAPTER_EVENTS, WalletLoginError } from '@web3auth/base';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport merge from 'lodash.merge';\nimport log from 'loglevel';\n\nconst getOpenloginDefaultOptions = (chainNamespace, chainId) => {\n  return {\n    adapterSettings: {\n      network: OPENLOGIN_NETWORK.MAINNET,\n      clientId: \"\",\n      uxMode: UX_MODE.POPUP\n    },\n    chainConfig: chainNamespace ? getChainConfig(chainNamespace, chainId) : undefined,\n    loginSettings: {\n      relogin: true\n    }\n  };\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass OpenloginAdapter extends BaseAdapter {\n  constructor(params) {\n    var _params$chainConfig, _params$chainConfig2, _params$chainConfig3;\n\n    super();\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.OPENLOGIN);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.MULTICHAIN);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.IN_APP);\n\n    _defineProperty(this, \"openloginInstance\", null);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"openloginOptions\", void 0);\n\n    _defineProperty(this, \"loginSettings\", {});\n\n    _defineProperty(this, \"privKeyProvider\", null);\n\n    log.debug(\"const openlogin adapter\", params);\n    const defaultOptions = getOpenloginDefaultOptions((_params$chainConfig = params.chainConfig) === null || _params$chainConfig === void 0 ? void 0 : _params$chainConfig.chainNamespace, (_params$chainConfig2 = params.chainConfig) === null || _params$chainConfig2 === void 0 ? void 0 : _params$chainConfig2.chainId);\n    this.openloginOptions = _objectSpread(_objectSpread({\n      clientId: \"\",\n      network: OPENLOGIN_NETWORK.MAINNET\n    }, defaultOptions.adapterSettings), params.adapterSettings || {});\n    this.loginSettings = _objectSpread(_objectSpread({}, defaultOptions.loginSettings), params.loginSettings); // if no chainNamespace is passed then chain config should be set before calling init\n\n    if ((_params$chainConfig3 = params.chainConfig) !== null && _params$chainConfig3 !== void 0 && _params$chainConfig3.chainNamespace) {\n      var _params$chainConfig4;\n\n      this.currentChainNamespace = (_params$chainConfig4 = params.chainConfig) === null || _params$chainConfig4 === void 0 ? void 0 : _params$chainConfig4.chainNamespace;\n      const defaultChainIdConfig = defaultOptions.chainConfig ? defaultOptions.chainConfig : {};\n      this.chainConfig = _objectSpread(_objectSpread({}, defaultChainIdConfig), params === null || params === void 0 ? void 0 : params.chainConfig);\n      log.debug(\"const openlogin chainConfig\", this.chainConfig);\n\n      if (!this.chainConfig.rpcTarget) {\n        throw WalletInitializationError.invalidParams(\"rpcTarget is required in chainConfig\");\n      }\n    }\n  }\n\n  get chainConfigProxy() {\n    return this.chainConfig ? _objectSpread({}, this.chainConfig) : null;\n  }\n\n  get provider() {\n    var _this$privKeyProvider;\n\n    return ((_this$privKeyProvider = this.privKeyProvider) === null || _this$privKeyProvider === void 0 ? void 0 : _this$privKeyProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options) {\n    var _this$openloginOption;\n\n    super.checkInitializationRequirements();\n    if (!((_this$openloginOption = this.openloginOptions) !== null && _this$openloginOption !== void 0 && _this$openloginOption.clientId)) throw WalletInitializationError.invalidParams(\"clientId is required before openlogin's initialization\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    this.openloginInstance = new OpenLogin(this.openloginOptions);\n    const redirectResult = getHashQueryParams();\n    let isRedirectResult = true;\n\n    if (Object.keys(redirectResult).length > 0 && redirectResult.result) {\n      isRedirectResult = true;\n    }\n\n    await this.openloginInstance.init();\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.OPENLOGIN);\n\n    try {\n      // connect only if it is redirect result or if connect (adapter is cached/already connected in same session) is true\n      if (this.openloginInstance.privKey && (options.autoConnect || isRedirectResult)) {\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached openlogin provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n\n  async connect(params) {\n    super.checkConnectionRequirements();\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, _objectSpread(_objectSpread({}, params), {}, {\n      adapter: WALLET_ADAPTERS.OPENLOGIN\n    }));\n\n    try {\n      await this.connectWithProvider(params);\n      return this.provider;\n    } catch (error) {\n      log.error(\"Failed to connect with openlogin provider\", error); // ready again to be connected\n\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n\n      if (error !== null && error !== void 0 && error.message.includes(\"user closed popup\")) {\n        throw WalletLoginError.popupClosed();\n      }\n\n      throw WalletLoginError.connectionError(\"Failed to login with openlogin\");\n    }\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    await this.openloginInstance.logout();\n\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.openloginInstance = null;\n      this.privKeyProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async getUserInfo() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    const userInfo = await this.openloginInstance.getUserInfo();\n    return userInfo;\n  } // should be called only before initialization.\n\n\n  setAdapterSettings(adapterSettings) {\n    if (this.status === ADAPTER_STATUS.READY) return;\n    const defaultOptions = getOpenloginDefaultOptions();\n    this.openloginOptions = _objectSpread(_objectSpread(_objectSpread({}, defaultOptions.adapterSettings), this.openloginOptions || {}), adapterSettings);\n  } // should be called only before initialization.\n\n\n  setChainConfig(customChainConfig) {\n    super.setChainConfig(customChainConfig);\n    this.currentChainNamespace = customChainConfig.chainNamespace;\n  }\n\n  async connectWithProvider(params) {\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n\n    if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n      const {\n        SolanaPrivateKeyProvider\n      } = await import('@web3auth/solana-provider');\n      this.privKeyProvider = new SolanaPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.EIP155) {\n      const {\n        EthereumPrivateKeyProvider\n      } = await import('@web3auth/ethereum-provider');\n      this.privKeyProvider = new EthereumPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else {\n      throw new Error(\"Invalid chainNamespace: \".concat(this.currentChainNamespace, \" found while connecting to wallet\"));\n    } // if not logged in then login\n\n\n    if (!this.openloginInstance.privKey && params) {\n      await this.openloginInstance.login(merge(this.loginSettings, {\n        loginProvider: params.loginProvider\n      }, {\n        extraLoginOptions: {\n          login_hint: params === null || params === void 0 ? void 0 : params.login_hint\n        }\n      }));\n    }\n\n    let finalPrivKey = this.openloginInstance.privKey;\n\n    if (finalPrivKey) {\n      if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n        const {\n          getED25519Key\n        } = await import('@toruslabs/openlogin-ed25519');\n        finalPrivKey = getED25519Key(finalPrivKey).sk.toString(\"hex\");\n      }\n\n      await this.privKeyProvider.setupProvider(finalPrivKey);\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.emit(ADAPTER_EVENTS.CONNECTED, {\n        adapter: WALLET_ADAPTERS.OPENLOGIN,\n        reconnected: !params\n      });\n    }\n  }\n\n}\n\nexport { OpenloginAdapter, getOpenloginDefaultOptions };\n//# sourceMappingURL=openloginAdapter.esm.js.map\n"]},"metadata":{},"sourceType":"module"}