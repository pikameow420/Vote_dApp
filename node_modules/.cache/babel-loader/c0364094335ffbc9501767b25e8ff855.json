{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport WalletConnect from '@walletconnect/client';\nimport { BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, CHAIN_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, getChainConfig, ADAPTER_EVENTS, WalletInitializationError, Web3AuthError, WalletLoginError, isHexStrict } from '@web3auth/base';\nimport { WalletConnectProvider } from '@web3auth/ethereum-provider';\nimport log from 'loglevel';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass WalletConnectV1Adapter extends BaseAdapter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.WALLET_CONNECT_V1);\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n    _defineProperty(this, \"adapterOptions\", void 0);\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n    _defineProperty(this, \"adapterData\", {\n      uri: \"\"\n    });\n    _defineProperty(this, \"connector\", null);\n    _defineProperty(this, \"wcProvider\", null);\n    _defineProperty(this, \"rehydrated\", false);\n    this.adapterOptions = _objectSpread({}, options);\n    this.chainConfig = options.chainConfig || null;\n  }\n  get connected() {\n    var _this$connector;\n    return !!((_this$connector = this.connector) !== null && _this$connector !== void 0 && _this$connector.connected);\n  }\n  get provider() {\n    var _this$wcProvider;\n    return ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.provider) || null;\n  }\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n  async init() {\n    super.checkInitializationRequirements();\n    if (!this.chainConfig) {\n      this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\n    } // Create a connector\n\n    this.connector = this.getWalletConnectInstance();\n    this.wcProvider = new WalletConnectProvider({\n      config: {\n        chainConfig: this.chainConfig\n      }\n    });\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n    this.status = ADAPTER_STATUS.READY;\n    if (this.connector.connected) {\n      this.rehydrated = true;\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId.toString()\n      });\n    }\n  }\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (this.connected) {\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId.toString()\n      });\n      return this.provider;\n    }\n    if (this.status !== ADAPTER_STATUS.CONNECTING) {\n      var _this$adapterOptions$;\n\n      // for wallet connect qr code modal we have to create a new connector, coz wallet connect internally does not open\n      // modal again on existing instance if connection is pending.\n      if ((_this$adapterOptions$ = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$ !== void 0 && _this$adapterOptions$.qrcodeModal) {\n        this.connector = this.getWalletConnectInstance();\n      }\n      await this.createNewSession();\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, {\n        adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1\n      });\n    }\n    return new Promise((resolve, reject) => {\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\")); // for wallet connect default modal.\n\n      this.connector.on(\"modal_closed\", async () => {\n        this.status = ADAPTER_STATUS.READY;\n        this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n        return reject(new Error(\"User closed modal\"));\n      });\n      try {\n        // Subscribe to session connection\n        this.connector.on(\"connect\", async (error, payload) => {\n          if (error) {\n            this.emit(ADAPTER_EVENTS.ERRORED, error);\n          }\n          await this.onConnectHandler(payload.params[0]);\n          return resolve(this.provider);\n        });\n      } catch (error) {\n        log.error(\"Wallet connect v1 adapter error while connecting\", error); // ready again to be connected\n\n        this.status = ADAPTER_STATUS.READY;\n        this.rehydrated = true;\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        reject(error instanceof Web3AuthError ? error : WalletLoginError.connectionError(\"Failed to login with wallet connect: \".concat((error === null || error === void 0 ? void 0 : error.message) || \"\")));\n      }\n    });\n  }\n  async getUserInfo() {\n    if (!this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    const {\n      cleanup\n    } = options;\n    if (!this.connector || !this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    await this.connector.killSession();\n    this.rehydrated = false;\n    if (cleanup) {\n      this.connector = null;\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.wcProvider = null;\n    } else {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.READY;\n    }\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n  async createNewSession() {\n    var _this$adapterOptions, _this$adapterOptions$2;\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      forceNewSession: false\n    };\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (opts.forceNewSession && this.connector.pending) {\n      await this.connector.killSession();\n    } // for wallet connect qr modal\n\n    if ((_this$adapterOptions = this.adapterOptions) !== null && _this$adapterOptions !== void 0 && (_this$adapterOptions$2 = _this$adapterOptions.adapterSettings) !== null && _this$adapterOptions$2 !== void 0 && _this$adapterOptions$2.qrcodeModal) {\n      var _this$chainConfig;\n      await this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainId) || \"0x1\", 16)\n      });\n      return;\n    } // for web3auth qr code modal\n\n    return new Promise((resolve, reject) => {\n      var _this$chainConfig2;\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\"));\n      log.debug(\"creating new session for web3auth wallet connect\");\n      this.connector.on(\"display_uri\", async (err, payload) => {\n        var _this$connector2;\n        if (err) {\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.connectionError(\"Failed to display wallet connect qr code\"));\n          return reject(err);\n        }\n        const uri = payload.params[0];\n        this.updateAdapterData({\n          uri\n        });\n        (_this$connector2 = this.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.off(\"display_uri\");\n        return resolve();\n      });\n      this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig2 = this.chainConfig) === null || _this$chainConfig2 === void 0 ? void 0 : _this$chainConfig2.chainId) || \"0x1\", 16)\n      }).catch(error => {\n        log.error(\"error while creating new wallet connect session\", error);\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        return reject(error);\n      });\n    });\n  }\n  async onConnectHandler(params) {\n    if (!this.connector || !this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"Chain config is not set\");\n    const {\n      chainId\n    } = params;\n    log.debug(\"connected chainId\", chainId);\n    const connectedChainId = parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n    if (connectedChainId !== parseInt(this.chainConfig.chainId, 16)) {\n      // we need to create a new session since old session is already used and\n      // user needs to login again with correct chain with new qr code.\n      await this.createNewSession({\n        forceNewSession: true\n      });\n      this.emit(ADAPTER_EVENTS.ERRORED, WalletInitializationError.fromCode(5000, \"Not connected to correct chainId. Expected: \".concat(this.chainConfig.chainId, \", Current: \").concat(connectedChainId, \", Please switch to correct chain from wallet\")));\n      return;\n    }\n    await this.wcProvider.setupProvider(this.connector);\n    this.subscribeEvents(this.connector);\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, {\n      adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1,\n      reconnected: this.rehydrated\n    });\n  }\n  subscribeEvents(connector) {\n    connector.on(\"session_update\", async error => {\n      if (error) {\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n      }\n    });\n  }\n  getWalletConnectInstance() {\n    const walletConnectOptions = this.adapterOptions.adapterSettings || {};\n    walletConnectOptions.bridge = walletConnectOptions.bridge || \"https://bridge.walletconnect.org\"; // Create a connector\n\n    return new WalletConnect(walletConnectOptions);\n  }\n}\nexport { WalletConnectV1Adapter };","map":{"version":3,"sources":["../src/walletConnectV1adapter.ts"],"names":["WalletConnectV1Adapter","BaseAdapter","WALLET_ADAPTERS","WALLET_CONNECT_V1","ADAPTER_NAMESPACES","EIP155","CHAIN_NAMESPACES","ADAPTER_CATEGORY","EXTERNAL","ADAPTER_STATUS","NOT_READY","uri","constructor","options","adapterOptions","chainConfig","connected","connector","provider","wcProvider","_","Error","init","checkInitializationRequirements","getChainConfig","getWalletConnectInstance","WalletConnectProvider","config","emit","ADAPTER_EVENTS","READY","status","rehydrated","onConnectHandler","accounts","chainId","toString","connect","checkConnectionRequirements","WalletInitializationError","notReady","CONNECTING","adapterSettings","qrcodeModal","createNewSession","adapter","Promise","resolve","reject","on","error","payload","ERRORED","params","log","Web3AuthError","WalletLoginError","connectionError","message","getUserInfo","notConnectedError","disconnect","cleanup","killSession","DISCONNECTED","opts","forceNewSession","pending","createSession","parseInt","debug","err","updateAdapterData","off","catch","invalidParams","connectedChainId","isHexStrict","fromCode","setupProvider","subscribeEvents","CONNECTED","reconnected","walletConnectOptions","bridge","WalletConnect"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport WalletConnect from '@walletconnect/client';\nimport { BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, CHAIN_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, getChainConfig, ADAPTER_EVENTS, WalletInitializationError, Web3AuthError, WalletLoginError, isHexStrict } from '@web3auth/base';\nimport { WalletConnectProvider } from '@web3auth/ethereum-provider';\nimport log from 'loglevel';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nclass WalletConnectV1Adapter extends BaseAdapter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.WALLET_CONNECT_V1);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n\n    _defineProperty(this, \"adapterOptions\", void 0);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"adapterData\", {\n      uri: \"\"\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    _defineProperty(this, \"wcProvider\", null);\n\n    _defineProperty(this, \"rehydrated\", false);\n\n    this.adapterOptions = _objectSpread({}, options);\n    this.chainConfig = options.chainConfig || null;\n  }\n\n  get connected() {\n    var _this$connector;\n\n    return !!((_this$connector = this.connector) !== null && _this$connector !== void 0 && _this$connector.connected);\n  }\n\n  get provider() {\n    var _this$wcProvider;\n\n    return ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    super.checkInitializationRequirements();\n\n    if (!this.chainConfig) {\n      this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\n    } // Create a connector\n\n\n    this.connector = this.getWalletConnectInstance();\n    this.wcProvider = new WalletConnectProvider({\n      config: {\n        chainConfig: this.chainConfig\n      }\n    });\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n    this.status = ADAPTER_STATUS.READY;\n\n    if (this.connector.connected) {\n      this.rehydrated = true;\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId.toString()\n      });\n    }\n  }\n\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (this.connected) {\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId.toString()\n      });\n      return this.provider;\n    }\n\n    if (this.status !== ADAPTER_STATUS.CONNECTING) {\n      var _this$adapterOptions$;\n\n      // for wallet connect qr code modal we have to create a new connector, coz wallet connect internally does not open\n      // modal again on existing instance if connection is pending.\n      if ((_this$adapterOptions$ = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$ !== void 0 && _this$adapterOptions$.qrcodeModal) {\n        this.connector = this.getWalletConnectInstance();\n      }\n\n      await this.createNewSession();\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, {\n        adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\")); // for wallet connect default modal.\n\n      this.connector.on(\"modal_closed\", async () => {\n        this.status = ADAPTER_STATUS.READY;\n        this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n        return reject(new Error(\"User closed modal\"));\n      });\n\n      try {\n        // Subscribe to session connection\n        this.connector.on(\"connect\", async (error, payload) => {\n          if (error) {\n            this.emit(ADAPTER_EVENTS.ERRORED, error);\n          }\n\n          await this.onConnectHandler(payload.params[0]);\n          return resolve(this.provider);\n        });\n      } catch (error) {\n        log.error(\"Wallet connect v1 adapter error while connecting\", error); // ready again to be connected\n\n        this.status = ADAPTER_STATUS.READY;\n        this.rehydrated = true;\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        reject(error instanceof Web3AuthError ? error : WalletLoginError.connectionError(\"Failed to login with wallet connect: \".concat((error === null || error === void 0 ? void 0 : error.message) || \"\")));\n      }\n    });\n  }\n\n  async getUserInfo() {\n    if (!this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    const {\n      cleanup\n    } = options;\n    if (!this.connector || !this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    await this.connector.killSession();\n    this.rehydrated = false;\n\n    if (cleanup) {\n      this.connector = null;\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.wcProvider = null;\n    } else {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async createNewSession() {\n    var _this$adapterOptions, _this$adapterOptions$2;\n\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      forceNewSession: false\n    };\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (opts.forceNewSession && this.connector.pending) {\n      await this.connector.killSession();\n    } // for wallet connect qr modal\n\n\n    if ((_this$adapterOptions = this.adapterOptions) !== null && _this$adapterOptions !== void 0 && (_this$adapterOptions$2 = _this$adapterOptions.adapterSettings) !== null && _this$adapterOptions$2 !== void 0 && _this$adapterOptions$2.qrcodeModal) {\n      var _this$chainConfig;\n\n      await this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainId) || \"0x1\", 16)\n      });\n      return;\n    } // for web3auth qr code modal\n\n\n    return new Promise((resolve, reject) => {\n      var _this$chainConfig2;\n\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\"));\n      log.debug(\"creating new session for web3auth wallet connect\");\n      this.connector.on(\"display_uri\", async (err, payload) => {\n        var _this$connector2;\n\n        if (err) {\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.connectionError(\"Failed to display wallet connect qr code\"));\n          return reject(err);\n        }\n\n        const uri = payload.params[0];\n        this.updateAdapterData({\n          uri\n        });\n        (_this$connector2 = this.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.off(\"display_uri\");\n        return resolve();\n      });\n      this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig2 = this.chainConfig) === null || _this$chainConfig2 === void 0 ? void 0 : _this$chainConfig2.chainId) || \"0x1\", 16)\n      }).catch(error => {\n        log.error(\"error while creating new wallet connect session\", error);\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        return reject(error);\n      });\n    });\n  }\n\n  async onConnectHandler(params) {\n    if (!this.connector || !this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"Chain config is not set\");\n    const {\n      chainId\n    } = params;\n    log.debug(\"connected chainId\", chainId);\n    const connectedChainId = parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n\n    if (connectedChainId !== parseInt(this.chainConfig.chainId, 16)) {\n      // we need to create a new session since old session is already used and\n      // user needs to login again with correct chain with new qr code.\n      await this.createNewSession({\n        forceNewSession: true\n      });\n      this.emit(ADAPTER_EVENTS.ERRORED, WalletInitializationError.fromCode(5000, \"Not connected to correct chainId. Expected: \".concat(this.chainConfig.chainId, \", Current: \").concat(connectedChainId, \", Please switch to correct chain from wallet\")));\n      return;\n    }\n\n    await this.wcProvider.setupProvider(this.connector);\n    this.subscribeEvents(this.connector);\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, {\n      adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1,\n      reconnected: this.rehydrated\n    });\n  }\n\n  subscribeEvents(connector) {\n    connector.on(\"session_update\", async error => {\n      if (error) {\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n      }\n    });\n  }\n\n  getWalletConnectInstance() {\n    const walletConnectOptions = this.adapterOptions.adapterSettings || {};\n    walletConnectOptions.bridge = walletConnectOptions.bridge || \"https://bridge.walletconnect.org\"; // Create a connector\n\n    return new WalletConnect(walletConnectOptions);\n  }\n\n}\n\nexport { WalletConnectV1Adapter };\n//# sourceMappingURL=walletConnectV1Adapter.esm.js.map\n"]},"metadata":{},"sourceType":"module"}