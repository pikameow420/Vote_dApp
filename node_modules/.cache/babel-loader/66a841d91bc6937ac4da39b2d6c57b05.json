{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = void 0;\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\nconst utils_1 = require(\"./utils\");\n/**\n * Create an Ethereum-specific signature for a message.\n *\n * This function is equivalent to the `eth_sign` Ethereum JSON-RPC method as specified in EIP-1417,\n * as well as the MetaMask's `personal_sign` method.\n *\n * @param options - The personal sign options.\n * @param options.privateKey - The key to sign with.\n * @param options.data - The hex data to sign.\n * @returns The '0x'-prefixed hex encoded signature.\n */\nfunction personalSign(_ref) {\n  let {\n    privateKey,\n    data\n  } = _ref;\n  if (utils_1.isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (utils_1.isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n  const message = utils_1.legacyToBuffer(data);\n  const msgHash = ethereumjs_util_1.hashPersonalMessage(message);\n  const sig = ethereumjs_util_1.ecsign(msgHash, privateKey);\n  const serialized = utils_1.concatSig(ethereumjs_util_1.toBuffer(sig.v), sig.r, sig.s);\n  return serialized;\n}\nexports.personalSign = personalSign;\n/**\n * Recover the address of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The signature recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded address of the message signer.\n */\nfunction recoverPersonalSignature(_ref2) {\n  let {\n    data,\n    signature\n  } = _ref2;\n  if (utils_1.isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (utils_1.isNullish(signature)) {\n    throw new Error('Missing signature parameter');\n  }\n  const publicKey = getPublicKeyFor(data, signature);\n  const sender = ethereumjs_util_1.publicToAddress(publicKey);\n  const senderHex = ethereumjs_util_1.bufferToHex(sender);\n  return senderHex;\n}\nexports.recoverPersonalSignature = recoverPersonalSignature;\n/**\n * Recover the public key of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The public key recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded public key of the message signer.\n */\nfunction extractPublicKey(_ref3) {\n  let {\n    data,\n    signature\n  } = _ref3;\n  if (utils_1.isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (utils_1.isNullish(signature)) {\n    throw new Error('Missing signature parameter');\n  }\n  const publicKey = getPublicKeyFor(data, signature);\n  return `0x${publicKey.toString('hex')}`;\n}\nexports.extractPublicKey = extractPublicKey;\n/**\n * Get the public key for the given signature and message.\n *\n * @param message - The message that was signed.\n * @param signature - The '0x'-prefixed hex encoded message signature.\n * @returns The public key of the signer.\n */\nfunction getPublicKeyFor(message, signature) {\n  const messageHash = ethereumjs_util_1.hashPersonalMessage(utils_1.legacyToBuffer(message));\n  return utils_1.recoverPublicKey(messageHash, signature);\n}","map":{"version":3,"sources":["../src/personal-sign.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,iBAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;AAQA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAOA;;;;;;;;;;AAUG;AACH,SAAgB,YAAY,OAM3B;EAAA,IAN4B;IAC3B,UAAU;IACV;EAAI,CAIL;EACC,IAAI,OAAA,CAAA,SAAS,CAAC,IAAI,CAAC,EAAE;IACnB,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC;GAC1C,MAAM,IAAI,OAAA,CAAA,SAAS,CAAC,UAAU,CAAC,EAAE;IAChC,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC;EAChD;EAED,MAAM,OAAO,GAAG,OAAA,CAAA,cAAc,CAAC,IAAI,CAAC;EACpC,MAAM,OAAO,GAAG,iBAAA,CAAA,mBAAmB,CAAC,OAAO,CAAC;EAC5C,MAAM,GAAG,GAAG,iBAAA,CAAA,MAAM,CAAC,OAAO,EAAE,UAAU,CAAC;EACvC,MAAM,UAAU,GAAG,OAAA,CAAA,SAAS,CAAC,iBAAA,CAAA,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;EAC3D,OAAO,UAAU;AACnB;AAlBA,OAAA,CAAA,YAAA,GAAA,YAAA;AAoBA;;;;;;;;AAQG;AACH,SAAgB,wBAAwB,QAMvC;EAAA,IANwC;IACvC,IAAI;IACJ;EAAS,CAIV;EACC,IAAI,OAAA,CAAA,SAAS,CAAC,IAAI,CAAC,EAAE;IACnB,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC;GAC1C,MAAM,IAAI,OAAA,CAAA,SAAS,CAAC,SAAS,CAAC,EAAE;IAC/B,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC;EAC/C;EAED,MAAM,SAAS,GAAG,eAAe,CAAC,IAAI,EAAE,SAAS,CAAC;EAClD,MAAM,MAAM,GAAG,iBAAA,CAAA,eAAe,CAAC,SAAS,CAAC;EACzC,MAAM,SAAS,GAAG,iBAAA,CAAA,WAAW,CAAC,MAAM,CAAC;EACrC,OAAO,SAAS;AAClB;AAjBA,OAAA,CAAA,wBAAA,GAAA,wBAAA;AAmBA;;;;;;;;AAQG;AACH,SAAgB,gBAAgB,QAM/B;EAAA,IANgC;IAC/B,IAAI;IACJ;EAAS,CAIV;EACC,IAAI,OAAA,CAAA,SAAS,CAAC,IAAI,CAAC,EAAE;IACnB,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC;GAC1C,MAAM,IAAI,OAAA,CAAA,SAAS,CAAC,SAAS,CAAC,EAAE;IAC/B,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC;EAC/C;EAED,MAAM,SAAS,GAAG,eAAe,CAAC,IAAI,EAAE,SAAS,CAAC;EAClD,OAAO,KAAK,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;AACzC;AAfA,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAiBA;;;;;;AAMG;AACH,SAAS,eAAe,CAAC,OAAgB,EAAE,SAAiB,EAAA;EAC1D,MAAM,WAAW,GAAG,iBAAA,CAAA,mBAAmB,CAAC,OAAA,CAAA,cAAc,CAAC,OAAO,CAAC,CAAC;EAChE,OAAO,OAAA,CAAA,gBAAgB,CAAC,WAAW,EAAE,SAAS,CAAC;AACjD","sourcesContent":["import {\n  bufferToHex,\n  ecsign,\n  hashPersonalMessage,\n  publicToAddress,\n  toBuffer,\n} from 'ethereumjs-util';\n\nimport {\n  concatSig,\n  isNullish,\n  legacyToBuffer,\n  recoverPublicKey,\n} from './utils';\n\n/**\n * Create an Ethereum-specific signature for a message.\n *\n * This function is equivalent to the `eth_sign` Ethereum JSON-RPC method as specified in EIP-1417,\n * as well as the MetaMask's `personal_sign` method.\n *\n * @param options - The personal sign options.\n * @param options.privateKey - The key to sign with.\n * @param options.data - The hex data to sign.\n * @returns The '0x'-prefixed hex encoded signature.\n */\nexport function personalSign({\n  privateKey,\n  data,\n}: {\n  privateKey: Buffer;\n  data: unknown;\n}): string {\n  if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  const message = legacyToBuffer(data);\n  const msgHash = hashPersonalMessage(message);\n  const sig = ecsign(msgHash, privateKey);\n  const serialized = concatSig(toBuffer(sig.v), sig.r, sig.s);\n  return serialized;\n}\n\n/**\n * Recover the address of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The signature recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded address of the message signer.\n */\nexport function recoverPersonalSignature({\n  data,\n  signature,\n}: {\n  data: unknown;\n  signature: string;\n}): string {\n  if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(signature)) {\n    throw new Error('Missing signature parameter');\n  }\n\n  const publicKey = getPublicKeyFor(data, signature);\n  const sender = publicToAddress(publicKey);\n  const senderHex = bufferToHex(sender);\n  return senderHex;\n}\n\n/**\n * Recover the public key of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The public key recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded public key of the message signer.\n */\nexport function extractPublicKey({\n  data,\n  signature,\n}: {\n  data: unknown;\n  signature: string;\n}): string {\n  if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(signature)) {\n    throw new Error('Missing signature parameter');\n  }\n\n  const publicKey = getPublicKeyFor(data, signature);\n  return `0x${publicKey.toString('hex')}`;\n}\n\n/**\n * Get the public key for the given signature and message.\n *\n * @param message - The message that was signed.\n * @param signature - The '0x'-prefixed hex encoded message signature.\n * @returns The public key of the signer.\n */\nfunction getPublicKeyFor(message: unknown, signature: string): Buffer {\n  const messageHash = hashPersonalMessage(legacyToBuffer(message));\n  return recoverPublicKey(messageHash, signature);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}