{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;\nconst nacl = __importStar(require(\"tweetnacl\"));\nconst naclUtil = __importStar(require(\"tweetnacl-util\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Encrypt a message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nfunction encrypt(_ref) {\n  let {\n    publicKey,\n    data,\n    version\n  } = _ref;\n  if (utils_1.isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (utils_1.isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (utils_1.isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n  switch (version) {\n    case 'x25519-xsalsa20-poly1305':\n      {\n        if (typeof data !== 'string') {\n          throw new Error('Message data must be given as a string');\n        }\n        // generate ephemeral keypair\n        const ephemeralKeyPair = nacl.box.keyPair();\n        // assemble encryption parameters - from string to UInt8\n        let pubKeyUInt8Array;\n        try {\n          pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);\n        } catch (err) {\n          throw new Error('Bad public key');\n        }\n        const msgParamsUInt8Array = naclUtil.decodeUTF8(data);\n        const nonce = nacl.randomBytes(nacl.box.nonceLength);\n        // encrypt\n        const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);\n        // handle encrypted data\n        const output = {\n          version: 'x25519-xsalsa20-poly1305',\n          nonce: naclUtil.encodeBase64(nonce),\n          ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n          ciphertext: naclUtil.encodeBase64(encryptedMessage)\n        };\n        // return encrypted msg data\n        return output;\n      }\n    default:\n      throw new Error('Encryption type/version not supported');\n  }\n}\nexports.encrypt = encrypt;\n/**\n * Encrypt a message in a way that obscures the message length.\n *\n * The message is padded to a multiple of 2048 before being encrypted so that the length of the\n * resulting encrypted message can't be used to guess the exact length of the original message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nfunction encryptSafely(_ref2) {\n  let {\n    publicKey,\n    data,\n    version\n  } = _ref2;\n  if (utils_1.isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (utils_1.isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (utils_1.isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n  const DEFAULT_PADDING_LENGTH = 2 ** 11;\n  const NACL_EXTRA_BYTES = 16;\n  if (typeof data === 'object' && 'toJSON' in data) {\n    // remove toJSON attack vector\n    // TODO, check all possible children\n    throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\n  }\n  // add padding\n  const dataWithPadding = {\n    data,\n    padding: ''\n  };\n  // calculate padding\n  const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\n  const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n  let padLength = 0;\n  // Only pad if necessary\n  if (modVal > 0) {\n    padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n  }\n\n  dataWithPadding.padding = '0'.repeat(padLength);\n  const paddedMessage = JSON.stringify(dataWithPadding);\n  return encrypt({\n    publicKey,\n    data: paddedMessage,\n    version\n  });\n}\nexports.encryptSafely = encryptSafely;\n/**\n * Decrypt a message.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nfunction decrypt(_ref3) {\n  let {\n    encryptedData,\n    privateKey\n  } = _ref3;\n  if (utils_1.isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (utils_1.isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n  switch (encryptedData.version) {\n    case 'x25519-xsalsa20-poly1305':\n      {\n        // string to buffer to UInt8Array\n        const recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);\n        const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey;\n        // assemble decryption parameters\n        const nonce = naclUtil.decodeBase64(encryptedData.nonce);\n        const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);\n        const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey);\n        // decrypt\n        const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey);\n        // return decrypted msg data\n        let output;\n        try {\n          output = naclUtil.encodeUTF8(decryptedMessage);\n        } catch (err) {\n          throw new Error('Decryption failed.');\n        }\n        if (output) {\n          return output;\n        }\n        throw new Error('Decryption failed.');\n      }\n    default:\n      throw new Error('Encryption type/version not supported.');\n  }\n}\nexports.decrypt = decrypt;\n/**\n * Decrypt a message that has been encrypted using `encryptSafely`.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nfunction decryptSafely(_ref4) {\n  let {\n    encryptedData,\n    privateKey\n  } = _ref4;\n  if (utils_1.isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (utils_1.isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n  const dataWithPadding = JSON.parse(decrypt({\n    encryptedData,\n    privateKey\n  }));\n  return dataWithPadding.data;\n}\nexports.decryptSafely = decryptSafely;\n/**\n * Get the encryption public key for the given key.\n *\n * @param privateKey - The private key to generate the encryption public key with.\n * @returns The encryption public key.\n */\nfunction getEncryptionPublicKey(privateKey) {\n  const privateKeyUint8Array = nacl_decodeHex(privateKey);\n  const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n  return naclUtil.encodeBase64(encryptionPublicKey);\n}\nexports.getEncryptionPublicKey = getEncryptionPublicKey;\n/**\n * Convert a hex string to the UInt8Array format used by nacl.\n *\n * @param msgHex - The string to convert.\n * @returns The converted string.\n */\nfunction nacl_decodeHex(msgHex) {\n  const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return naclUtil.decodeBase64(msgBase64);\n}","map":{"version":3,"sources":["../src/encryption.ts"],"names":[],"mappings":"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","sourcesContent":["import * as nacl from 'tweetnacl';\nimport * as naclUtil from 'tweetnacl-util';\n\nimport { isNullish } from './utils';\n\nexport interface EthEncryptedData {\n  version: string;\n  nonce: string;\n  ephemPublicKey: string;\n  ciphertext: string;\n}\n\n/**\n * Encrypt a message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nexport function encrypt({\n  publicKey,\n  data,\n  version,\n}: {\n  publicKey: string;\n  data: unknown;\n  version: string;\n}): EthEncryptedData {\n  if (isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  switch (version) {\n    case 'x25519-xsalsa20-poly1305': {\n      if (typeof data !== 'string') {\n        throw new Error('Message data must be given as a string');\n      }\n      // generate ephemeral keypair\n      const ephemeralKeyPair = nacl.box.keyPair();\n\n      // assemble encryption parameters - from string to UInt8\n      let pubKeyUInt8Array;\n      try {\n        pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);\n      } catch (err) {\n        throw new Error('Bad public key');\n      }\n\n      const msgParamsUInt8Array = naclUtil.decodeUTF8(data);\n      const nonce = nacl.randomBytes(nacl.box.nonceLength);\n\n      // encrypt\n      const encryptedMessage = nacl.box(\n        msgParamsUInt8Array,\n        nonce,\n        pubKeyUInt8Array,\n        ephemeralKeyPair.secretKey,\n      );\n\n      // handle encrypted data\n      const output = {\n        version: 'x25519-xsalsa20-poly1305',\n        nonce: naclUtil.encodeBase64(nonce),\n        ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n        ciphertext: naclUtil.encodeBase64(encryptedMessage),\n      };\n      // return encrypted msg data\n      return output;\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported');\n  }\n}\n\n/**\n * Encrypt a message in a way that obscures the message length.\n *\n * The message is padded to a multiple of 2048 before being encrypted so that the length of the\n * resulting encrypted message can't be used to guess the exact length of the original message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nexport function encryptSafely({\n  publicKey,\n  data,\n  version,\n}: {\n  publicKey: string;\n  data: unknown;\n  version: string;\n}): EthEncryptedData {\n  if (isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  const DEFAULT_PADDING_LENGTH = 2 ** 11;\n  const NACL_EXTRA_BYTES = 16;\n\n  if (typeof data === 'object' && 'toJSON' in data) {\n    // remove toJSON attack vector\n    // TODO, check all possible children\n    throw new Error(\n      'Cannot encrypt with toJSON property.  Please remove toJSON property',\n    );\n  }\n\n  // add padding\n  const dataWithPadding = {\n    data,\n    padding: '',\n  };\n\n  // calculate padding\n  const dataLength = Buffer.byteLength(\n    JSON.stringify(dataWithPadding),\n    'utf-8',\n  );\n  const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n  let padLength = 0;\n  // Only pad if necessary\n  if (modVal > 0) {\n    padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n  }\n  dataWithPadding.padding = '0'.repeat(padLength);\n\n  const paddedMessage = JSON.stringify(dataWithPadding);\n  return encrypt({ publicKey, data: paddedMessage, version });\n}\n\n/**\n * Decrypt a message.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nexport function decrypt({\n  encryptedData,\n  privateKey,\n}: {\n  encryptedData: EthEncryptedData;\n  privateKey: string;\n}): string {\n  if (isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  switch (encryptedData.version) {\n    case 'x25519-xsalsa20-poly1305': {\n      // string to buffer to UInt8Array\n      const recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);\n      const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(\n        recieverPrivateKeyUint8Array,\n      ).secretKey;\n\n      // assemble decryption parameters\n      const nonce = naclUtil.decodeBase64(encryptedData.nonce);\n      const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);\n      const ephemPublicKey = naclUtil.decodeBase64(\n        encryptedData.ephemPublicKey,\n      );\n\n      // decrypt\n      const decryptedMessage = nacl.box.open(\n        ciphertext,\n        nonce,\n        ephemPublicKey,\n        recieverEncryptionPrivateKey,\n      );\n\n      // return decrypted msg data\n      let output;\n      try {\n        output = naclUtil.encodeUTF8(decryptedMessage);\n      } catch (err) {\n        throw new Error('Decryption failed.');\n      }\n\n      if (output) {\n        return output;\n      }\n      throw new Error('Decryption failed.');\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported.');\n  }\n}\n\n/**\n * Decrypt a message that has been encrypted using `encryptSafely`.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nexport function decryptSafely({\n  encryptedData,\n  privateKey,\n}: {\n  encryptedData: EthEncryptedData;\n  privateKey: string;\n}): string {\n  if (isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  const dataWithPadding = JSON.parse(decrypt({ encryptedData, privateKey }));\n  return dataWithPadding.data;\n}\n\n/**\n * Get the encryption public key for the given key.\n *\n * @param privateKey - The private key to generate the encryption public key with.\n * @returns The encryption public key.\n */\nexport function getEncryptionPublicKey(privateKey: string): string {\n  const privateKeyUint8Array = nacl_decodeHex(privateKey);\n  const encryptionPublicKey =\n    nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n  return naclUtil.encodeBase64(encryptionPublicKey);\n}\n\n/**\n * Convert a hex string to the UInt8Array format used by nacl.\n *\n * @param msgHex - The string to convert.\n * @returns The converted string.\n */\nfunction nacl_decodeHex(msgHex: string): Uint8Array {\n  const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return naclUtil.decodeBase64(msgBase64);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}